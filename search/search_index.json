{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Die Graphschaft Schilda","text":""},{"location":"#abstract","title":"Abstract","text":"<p>Diese Website ist die Dokumentation des Projektes \"Graphschaft Schilda\" f\u00fcr das Modul Programmiertechnik III an der TH Aschaffenburg.</p> <p>Die Graphschaft Schilda ist ein beschauliches \u00d6rtchen irgendwo im Nichts.  Lange Zeit blieb diese Graphschaft unbehelligt vom Fortschritt, nichts tat sich in dem  \u00d6rtchen. Eines Tages jedoch machte sich dort pl\u00f6tzlich das Ger\u00fccht breit, dass fernab der Graphschaft intelligente Menschen leben, die (fast) alle Probleme der Welt mit m\u00e4chtigen Algorithmen l\u00f6sen k\u00f6nnten. Die B\u00fcrger der Graphschaft machten sich also auf den Weg um diese intelligenten Menschen mit der L\u00f6sung ihrer Probleme zu beauftragen....</p>"},{"location":"#aufgabenstellung","title":"Aufgabenstellung","text":"<p>Entwickeln Sie ein Planungstool, dass der Graphschaft Schilda bei der L\u00f6sung ihrer Probleme hilft.  </p> <ol> <li>Analysieren Sie jedes der Probleme: Welche Daten sollen verarbeitet werden? Was sind die Eingaben? Was die Ausgaben? Welcher Algorithmus eignet sich? Welche Datenstruktur eignet sich? </li> <li>Implementieren Sie den Algorithmus (in Java), so dass bei Eingabe der entsprechenden Daten die gew\u00fcnschte Ausgabe berechnet und ausgegeben wird. </li> <li>Geben Sie f\u00fcr jeden implementierten Algorithmus die Laufzeit an. Da Sie sich nun schon so viel M\u00fche mit dem Tool geben, wollen Sie das Tool nat\u00fcrlich auch an andere  Gemeinden verkaufen. Die Eingaben sollen daf\u00fcr generisch, d.h., f\u00fcr neue Orte, Feiern und Planungen anpassbar sein. Sie k\u00f6nnen diese Aufgabe ein 2er oder 3er Teams l\u00f6sen. Bitte geben Sie dann die Arbeitsteilung im Dokument mit an. Die 15min\u00fctige Einzelpr\u00fcfung wird auf die Projektaufgabe eingehen. </li> </ol>"},{"location":"#planungstool-aufbau","title":"Planungstool Aufbau","text":""},{"location":"#das-interface","title":"Das Interface","text":"<p>Sobald das Programm startet, \u00f6ffnet sich ein Fenster mit einem Men\u00fc f\u00fcr die Auswahl der verschiedenen Probleme. Wenn ein Knopf gedr\u00fcckt wird, \u00f6ffnet sich ein neues Fenster mit dem entsprechenden Problem. </p>"},{"location":"#die-aufgaben","title":"Die Aufgaben","text":"<p>Jedes Problem besitzt eine eigene Klasse <code>ProblemX.java</code>, die sich im Ordner <code>code</code> befinden. </p> <p>Der Ordner <code>code/utils</code> enth\u00e4lt die Klassen:</p> <ul> <li> <p><code>AdjazenzMatrix.java</code>: Speichert eine <code>int[][]</code> Matrix, <code>char[]</code> Buchstaben-Array und ob es sich um einen gerichteten oder ungerichteten Graphen handelt.</p> </li> <li> <p><code>FileHandler.java</code>: Stellt Methoden zum Einlesen und Schreiben von Dateien bereit.</p> </li> <li> <p><code>Vertex.java</code>: Speichert einen Buchstaben, einen Vertex-Vorg\u00e4nger, einen 'key' und eine Option ob der Vertex bereits besucht wurde.</p> </li> <li> <p><code>Edge.java</code>: Speichert zwei Buchstaben f\u00fcr den Start- und Endknoten der Kante und ein Gewicht.</p> </li> <li> <p><code>JGraphPanel.java</code>: Eine Klasse, die ein <code>JPanel</code> erweitert und mit Hilfe der mxgraph und jgrapht Bibliotheken einen Graphen zeichnet.</p> </li> <li> <p><code>BasicWindow.java</code>: Eine Klasse, die ein <code>JFrame</code> erweitert und als Grundlage f\u00fcr die Fenster der einzelnen Probleme dient.</p> </li> </ul>"},{"location":"#die-eingabe","title":"Die Eingabe","text":"<p>Die Eingabedateien befinden sich in dem Ordner <code>data</code> und folgen dem Namensschema <code>problemX.txt</code>. Die Dateien werden mit der Klasse <code>FileHandler.java</code> eingelesen und in einer Instanz der Klasse <code>AdjazenzMatrix.java</code> gespeichert. </p> <pre><code>Ungerichteter Graph      Gerichteter Graph\n  A B C ...                A B C ...\nA 0                      A 0 0 1\nB 1 0                    B 0 0 1\nC 2 3 0                  C 1 0 0\n...                      ...\n</code></pre>"},{"location":"#die-ausgabe","title":"Die Ausgabe","text":"<p>Die Ausgabedateien befinden sich in dem Ordner <code>output</code> und werden automatisch generiert oder \u00fcberschrieben sobald ein Punkt aus dem Men\u00fc ausgew\u00e4hlt wird.</p> <p>Beim Bet\u00e4tigen eines Men\u00fcbuttons wird die Ein- und Ausgabe graphisch dargestellt und zus\u00e4tzlich in der Konsole ausgegeben.</p> <p>In der Ausgabedatei werden die Graphen in einer Adjazenzmatrix gespeichert, die dem Schema der Eingabedatei entspricht. </p>"},{"location":"#das-team","title":"Das Team","text":"<ul> <li>Felix M\u00f6hler - GitHub</li> <li>Julian Thiele - GitHub</li> </ul>"},{"location":"#auftraggeber","title":"Auftraggeber","text":"<p>Prof. Barbara Sprick - Professorin f\u00fcr Praktische Informatik bei TH Aschaffenburg</p>"},{"location":"Problem1/","title":"Problem 1 - \"Stra\u00dfen m\u00fcssen her!\"","text":"<p>Lange Zeit gab es in der Graphschaft Schilda einen Reformstau, kein Geld floss mehr in die Infrastruktur. Wie es kommen musste, wurde der Zustand der Stadt zusehends schlechter, bis die B\u00fcrger der Graphschaft den Aufbau Ihrer Stadt nun endlich selbst in die Hand nahmen. Zun\u00e4chst einmal sollen neue Stra\u00dfen gebaut werden. Zur Zeit gibt es nur einige schlammige Wege zwischen den H\u00e4usern. Diese sollen nun gepflastert werden, so dass von jedem Haus jedes andere Haus erreichbar ist. </p> <p>Da die B\u00fcrger der Stadt arm sind, soll der Stra\u00dfenbau insgesamt m\u00f6glichst wenig kosten. Die B\u00fcrger haben bereits einen Plan mit m\u00f6glichen Wegen erstellt. Ihre Aufgabe ist nun, das kosteng\u00fcnstigste Wegenetz zu berechnen, so dass alle H\u00e4user miteinander verbunden sind (nehmen Sie dabei pro Pflasterstein Kosten von 1 an):</p>"},{"location":"Problem1/#modellierung-des-problems","title":"Modellierung des Problems","text":"<p>Das Problem l\u00e4sst sich als Graphenmodell mit ungerichteten Kanten darstellen. Jedes Haus ist ein Knoten, die Stra\u00dfen sind die Kanten. Die Kosten der Kanten sind die Kosten f\u00fcr die Pflastersteine. </p> <p>Es wird eine Konfiguration an Kanten gesucht, die eine minimale Anzahl an Pflastersteinen ben\u00f6tigt.</p> <p>Um den Graph zu modellieren werden die Java-Bibliotheken <code>JGraphT</code> und <code>JGraphX</code> verwendet. Mit <code>JGraphT</code> wird der Graph als Datenstruktur modelliert. Mit <code>JGraphX</code> wird der Graph als Grafik dargestellt und auf dem Bildschirm dargestellt.</p>"},{"location":"Problem1/#die-eingabe","title":"Die Eingabe","text":"<p>Die Eingabe besteht aus einem Graphen, der aus Kanten und Knoten besteht. Diese werden aus einer <code>.txt</code> Datei gelesen und in eine Instanz der Klasse <code>AdjazenzMatrix.java</code> geladen. Diese Instanz dient als Basis f\u00fcr die Berechnung des minimalen Spannbaums.</p> <p>Das Bild aus der Aufgabenstellung wurde mit Buchstaben von A bis J beschriftet und daraus wurde die Datei <code>problem1.txt</code> erstellt.</p>  <pre><code>// code/data/problem1.txt\n  A B C D E F G H I J\nA 0\nB 5 0\nC 3 3 0\nD 0 3 0 0\nE 4 0 5 0 0\nF 0 2 3 0 0 0\nG 0 0 4 0 4 4 0\nH 0 0 0 0 2 0 3 0\nI 0 0 0 0 0 3 2 4 0\nJ 0 4 0 2 0 3 0 0 4 0\n</code></pre>"},{"location":"Problem1/#die-ausgabe","title":"Die Ausgabe","text":"<p>Die Ausgabe wird als Graph in einem Fenster dargestellt und in die Datei <code>1 Stra\u00dfenplaner.txt</code> geschrieben. Das Fenster besteht aus zwei H\u00e4lften. Auf der linken Seite wird der Eingabegraph dargestellt. Auf der rechten Seite wird der berechnete Graph dargestellt. </p> <p>Ein korrekte Ausgabe erf\u00fcllt folgende Eigenschaften:</p> <ul> <li> <p>Die Summe der Kantengewichte muss minimal sein.</p> </li> <li> <p>Alle Knoten m\u00fcssen \u00fcber Kanten erreichbar sein.</p> </li> <li> <p>Der Graph muss zusammenh\u00e4ngend und zyklusfrei sein.</p> </li> <li> <p>Die Kanten m\u00fcssen ungerichtet sein.</p> </li> <li> <p>Alle Knoten des Eingabe-Graphen m\u00fcssen im Ausgabe-Graphen enthalten sein.</p> </li> </ul>  <pre><code>// code/output/1 Stra\u00dfenplaner.txt\n  A B C D E F G H I J \nA 0 \nB 0 0 \nC 3 3 0 \nD 0 3 0 0 \nE 0 0 0 0 0 \nF 0 2 0 0 0 0 \nG 0 0 0 0 0 0 0 \nH 0 0 0 0 2 0 3 0 \nI 0 0 0 0 0 3 2 0 0 \nJ 0 0 0 2 0 0 0 0 0 0 \n</code></pre>"},{"location":"Problem1/#geeignete-algorithmen","title":"Geeignete Algorithmen","text":"<p>F\u00fcr dieses Problem eigenen sich die Algorithmen von Prim und Kruskal. Beide Algorithmen berechnen den minimalen Spannbaum eines Graphen.</p>"},{"location":"Problem1/#die-laufzeit-des-algorithmus","title":"Die Laufzeit des Algorithmus","text":"<p>TODO Laufzeitberechnung <code>O(|E| + |V| log |V|)</code> (Hier bitte auch eine Begr\u00fcndung einf\u00fcgen, ein ausf\u00fchrlicher Beweis ist nicht notwendig.)</p>"},{"location":"Problem1/#die-implementierung-des-algorithmus","title":"Die Implementierung des Algorithmus","text":"<p>Zur L\u00f6sung des Problems wurde der Algorithmus von Prim implementiert. Der Algorithmus von Prim ist ein Greedy-Algorithmus. Als Datenstruktur wurde eine Priorit\u00e4tswarteschlange verwendet, die Instanzen der Klasse <code>Vertex</code> beinhaltet: </p> <p>Zuerst wird eine Liste aller Knoten und Kanten erstellt. Die Knoten werden mit dem maximalen Wert f\u00fcr Integer und ohne Vorg\u00e4nger initialisiert. Anschlie\u00dfend wird ein beliebiger Knoten als Startknoten gew\u00e4hlt (In diesem Fall der Erste). Der Startknoten bekommt den Wert <code>0</code>. Alle Knoten werden in eine Priorit\u00e4tswarteschlange <code>Q</code> eingef\u00fcgt.</p> <p>Danach wird eine while-Schleife verwendet um alle Knoten zu durchlaufen. In der Schleife wird der Knoten mit dem kleinsten Wert aus der Warteschlange <code>Q</code> entfernt. Anschlie\u00dfend wird f\u00fcr jeden Nachbarknoten des aktuellen Knotens \u00fcberpr\u00fcft, ob der Wert des Nachbarknotens gr\u00f6\u00dfer als der Wert des aktuellen Knotens plus der Kosten der Kante ist. Wenn dies der Fall ist, wird der Wert des Nachbarknotens auf den Wert des aktuellen Knotens plus die Kosten der Kante gesetzt und der Vorg\u00e4nger des Nachbarknotens auf den aktuellen Knoten gesetzt.</p> <p>Am Ende wird die Liste aller Knoten in eine Adjazenzmatrix umgewandelt und zur\u00fcckgegeben.</p> <pre><code>private int[][] prim(AdjazenzMatrix input) {\n\n  int[][] matrix = input.getMatrixCopy();\n  char[] vertexLetters = input.getVertexLetters();\n\n  ArrayList&lt;Vertex&gt; vertices = new ArrayList&lt;&gt;();\n  ArrayList&lt;Edge&gt; edges = getEdges(matrix, vertexLetters);\n\n  // Generiere eine Liste aller Knoten mit dem Wert unendlich und ohne Vorg\u00e4nger\n  for (int i = 0; i &lt; matrix.length; i++)\n    vertices.add(new Vertex(vertexLetters[i], Integer.MAX_VALUE, null));\n\n  // Starte mit beliebigem Startknoten, Startknoten bekommt den Wert 0\n  vertices.get(0).setKey(0);\n\n  // Speichere alle Knoten in einer geeigneten Datenstruktur Q\n  // -&gt; Priorit\u00e4tswarteschlange\n  PriorityQueue&lt;Vertex&gt; q = new PriorityQueue&lt;&gt;(Comparator.comparingInt(Vertex::getKey));\n  q.addAll(vertices);\n\n  // Solange es noch Knoten in Q gibt...\n  while (!q.isEmpty()) {\n    // Entnehme den Knoten mit dem kleinsten Wert\n    Vertex u = q.poll();\n\n    // F\u00fcr jeden Nachbarn n von u\n    for (Vertex n : getNeighbors(u, vertices, edges)) {\n      // Finde die Kante (u, n)\n      Edge e = null;\n      for (Edge edge : edges)\n        if ((edge.getSource() == u.getLetter() &amp;&amp; edge.getTarget() == n.getLetter())\n            || (edge.getSource() == n.getLetter() &amp;&amp; edge.getTarget() == u.getLetter()))\n          e = edge;\n\n      // Wenn n in Q und das Gewicht der Kante (u, n) kleiner ist als der Wert von n\n      if (!q.contains(n) || e.getWeight() &gt;= n.getKey())\n        continue;\n\n      // Setze den Wert von n auf das Gewicht der Kante (u, n)\n      n.setKey(e.getWeight());\n      // Setze den Vorg\u00e4nger von n auf u\n      n.setPredecessor(u);\n      // Aktualisiere die Position von n in Q\n      q.remove(n);\n      q.add(n);\n    }\n  }\n\n  // Erstelle die Adjazenzmatrix f\u00fcr den Minimum Spanning Tree\n  int[][] matrix_output = new int[matrix.length][matrix.length];\n  for (Vertex v : vertices) {\n    if (v.getPredecessor() == null)\n      continue;\n\n    int i = v.getLetter() - 'A';\n    int j = v.getPredecessor().getLetter() - 'A';\n    matrix_output[i][j] = matrix[i][j];\n    matrix_output[j][i] = matrix[j][i];\n  }\n  return matrix_output;\n}\n</code></pre>"},{"location":"Problem2/","title":"Problem 2 - \"Wasserversorgung\"","text":"<p>Der Stra\u00dfenbau in der Graphschaft Schilda war erfolgreich, die Stadt bl\u00fcht und gedeiht wieder! Selbst ein neuer Supermarkt soll er\u00f6ffnet werden. Nun muss dieser aber mit Wasser versorgt werden, und da Sie bereits das Stra\u00dfenbauprojekt so erfolgreich durchgef\u00fchrt haben, werden Sie nun auch damit beauftragt, den neuen Supermarkt an die Wasserversorgung anzuschlie\u00dfen. </p> <p>Da die Stadt nach wie vor kein Geld verschwenden m\u00f6chte, m\u00fcssen Sie zun\u00e4chst feststellen, ob das bestehende Leitungsnetz noch ausreichend Kapazit\u00e4t f\u00fcr den zus\u00e4tzlichen Wasserverbrauch hat, oder ob neue Leitungen ben\u00f6tigt werden. Da die Graphschaft Schilda noch keine Pumpen kennt, kann das Wasser nur bergab flie\u00dfen. Als Vorarbeit haben Ihnen die B\u00fcrger die bestehende Wasserversorgung und die Lage des neuen Supermarktes aufgezeichnet:</p>"},{"location":"Problem2/#modellierung-des-problems","title":"Modellierung des Problems","text":""},{"location":"Problem2/#die-eingabe","title":"Die Eingabe","text":""},{"location":"Problem2/#die-ausgabe","title":"Die Ausgabe","text":""},{"location":"Problem2/#der-alrogithmus","title":"Der Alrogithmus","text":""},{"location":"Problem2/#die-laufzeit-des-algorithmus","title":"Die Laufzeit des Algorithmus","text":""},{"location":"Problem2/#die-implementierung-des-algorithmus","title":"Die Implementierung des Algorithmus","text":""},{"location":"Problem3/","title":"Problem 3 - \"Stromversorgung\"","text":"<p>Die Stadt floriert, alles wird moderner und so muss auch die Stromversorgung erneuert werden. Die Stadt hat bereits eruiert, wo Strommasten aufgestellt werden k\u00f6nnen. Sie haben auch festgestellt, dass es keine Barrieren in der Stadt gibt, d.h., prinzipiell k\u00f6nnten alle Strommasten miteinander verbunden werden. Aber nat\u00fcrlich wollen wir lange Leitungen m\u00f6glichst vermeiden. </p> <p>Deswegen schr\u00e4nken wir von vornherein ein, dass jeder Strommast nur mit maximal 5 n\u00e4chsten Nachbarn verbunden werden darf.  Es stellt sich heraus, dass dies immer noch zu teuer ist. Deswegen soll dieses Netz noch einmal so reduziert werden, dass zwar alle Strommasten miteinander verbunden sind, aber Kosten insgesamt minimal sind. Wir nehmen dabei an, dass die Kosten ausschlie\u00dflich von der Leitungsl\u00e4nge abh\u00e4ngen. </p>"},{"location":"Problem3/#modellierung-des-problems","title":"Modellierung des Problems","text":"<p>Das Problem l\u00e4sst sich als Graphenmodell mit ungerichteten Kanten darstellen. Jeder Strommast ist ein Knoten, die Verbindungen sind die Kanten. Die Kosten der Kanten sind die L\u00e4nge der Stromleitungen. </p> <p>Es wird eine Konfiguration an Leitungen zwischen den Strommasten gesucht, die eine minimale Gesamtl\u00e4nge besitzt, und jeder Strommast mit maximal mit 5 weiteren Masten verbunden sein darf.</p> <p>Um den Graph zu modellieren werden die Java-Bibliotheken <code>JGraphT</code> und <code>JGraphX</code> verwendet. Mit <code>JGraphT</code> wird der Graph als Datenstruktur modelliert. Mit <code>JGraphX</code> wird der Graph als Grafik dargestellt und auf dem Bildschirm dargestellt.</p>"},{"location":"Problem3/#die-eingabe","title":"Die Eingabe","text":"<p>Die Eingabe besteht aus einem Graphen, der aus Kanten und Knoten besteht. Diese werden aus einer <code>.txt</code> Datei gelesen und in eine Instanz der Klasse <code>AdjazenzMatrix.java</code> geladen. Diese Instanz dient als Basis f\u00fcr die Berechnung des minimalen Spannbaums.</p> <p>Der Eingabegraph besteht aus 12 Knoten und 66 Kanten. Die Kanten werden mit aufsteigenden Gewichten generiert. Die Knoten werden mit Buchstaben von A - L bezeichnet.</p> <p>Zus\u00e4tzlich ist im Code hinterlegt, dass die maximale Anzahl an Nachbarn pro Knoten 5 ist.</p> <pre><code>// code/data/problem3.txt\n  A B C D E F G H I J K L\nA 0\nB 1 0\nC 2 3 0\nD 4 5 6 0\nE 7 7 9 10 0\nF 11 12 13 14 15 0\nG 16 17 18 19 20 21 0\nH 22 23 24 25 26 27 28 0\nI 29 30 31 32 33 34 35 36 0\nJ 37 38 39 40 41 42 43 44 45 0\nK 46 47 48 49 50 51 52 53 54 55 0\nL 56 57 58 59 60 61 62 63 64 65 66 0\n</code></pre>"},{"location":"Problem3/#die-ausgabe","title":"Die Ausgabe","text":"<p>Die Ausgabe wird als Graph in einem Fenster dargestellt und in die Datei <code>3 Stromversorgung.txt</code> geschrieben. Das Fenster besteht aus zwei H\u00e4lften. Auf der linken Seite wird der Eingabegraph dargestellt. Auf der rechten Seite wird der berechnete Graph dargestellt. </p> <p>Ein korrekte Ausgabe erf\u00fcllt folgende Eigenschaften:</p> <ul> <li> <p>Die Summe der Kantengewichte muss minimal sein.</p> </li> <li> <p>Die Anzahl der Kanten darf maximal 5 sein.</p> </li> <li> <p>Alle Knoten m\u00fcssen \u00fcber Kanten erreichbar sein.</p> </li> <li> <p>Der Graph muss zusammenh\u00e4ngend und zyklusfrei sein.</p> </li> <li> <p>Die Kanten m\u00fcssen ungerichtet sein.</p> </li> <li> <p>Alle Knoten des Eingabe-Graphen m\u00fcssen im Ausgabe-Graphen enthalten sein.</p> </li> </ul>  <pre><code>// code/output/3 Stromversorgungsplaner.txt\n  A B C D E F G H I J K L \nA 0 \nB 1 0 \nC 2 0 0 \nD 4 0 0 0 \nE 7 0 0 0 0 \nF 11 0 0 0 0 0 \nG 0 17 0 0 0 0 0 \nH 0 23 0 0 0 0 0 0 \nI 0 30 0 0 0 0 0 0 0 \nJ 0 38 0 0 0 0 0 0 0 0 \nK 0 0 48 0 0 0 0 0 0 0 0 \nL 0 0 58 0 0 0 0 0 0 0 0 0 \n</code></pre>"},{"location":"Problem3/#geeignete-algorithmen","title":"Geeignete Algorithmen","text":"<p>F\u00fcr dieses Problem eigenen sich die Algorithmen von Prim und Kruskal. Beide Algorithmen berechnen den minimalen Spannbaum eines Graphen.</p>"},{"location":"Problem3/#die-laufzeit-des-algorithmus","title":"Die Laufzeit des Algorithmus","text":"<p>TODO</p>"},{"location":"Problem3/#die-implementierung-des-algorithmus","title":"Die Implementierung des Algorithmus","text":"<p>Zur L\u00f6sung dieses Problems wurde der Algorithmus von Kruskal verwendet. Der Algorithmus ist ein Greedy-Algorithmus. Er berechnet den minimalen Spannbaum eines Graphen.</p> <p>Zuerst wird eine Liste aller Kanten des Graphen erstellt. Diese Liste wird nach Gewicht sortiert. Dann wird ein Wald aus B\u00e4umen erstellt, wobei jeder Knoten ein eigener Baum ist. Dann wird die Liste der Kanten durchlaufen. </p> <p>Wenn die Kanten zwei Knoten aus verschiedenen B\u00e4umen verbindet, wird die Kante dem minimalen Spannbaum hinzugef\u00fcgt. Die B\u00e4ume werden dann zusammengef\u00fchrt.</p> <p>Die Funktion gibt eine Adjazenmatrix zur\u00fcck, die aus der Liste der Ausgabe-Kanten erstellt wird.</p> <pre><code>private int[][] kruskal(AdjazenzMatrix input, int max_edges) {\n\n  int[][] matrix = input.getMatrixCopy();\n  char[] vertexLetters = input.getVertexLetters();\n\n  ArrayList&lt;Vertex&gt; vertices = new ArrayList&lt;&gt;();\n\n  // Generiere eine Liste aller Knoten\n  for (int i = 0; i &lt; matrix.length; i++)\n    vertices.add(new Vertex(vertexLetters[i], 0));\n\n  ArrayList&lt;Edge&gt; edges = getEdges(matrix, vertexLetters);\n\n  // Sortiere die Kanten nach Gewicht\n  edges.sort(Comparator.comparingInt(Edge::getWeight));\n\n  // erstelle einen wald 'forest' (eine menge von b\u00e4umen), wo jeder knoten ein\n  // eigener baum ist\n  ArrayList&lt;ArrayList&lt;Vertex&gt;&gt; forest = new ArrayList&lt;ArrayList&lt;Vertex&gt;&gt;();\n  for (Vertex v : vertices) {\n    ArrayList&lt;Vertex&gt; tree = new ArrayList&lt;Vertex&gt;();\n    tree.add(v);\n    forest.add(tree);\n  }\n\n  // erstelle eine liste mit den kanten des minimum spanning trees\n  ArrayList&lt;Edge&gt; forest_edges = new ArrayList&lt;Edge&gt;(edges);\n\n  // erstelle eine liste f\u00fcr die Ausgabe\n  ArrayList&lt;Edge&gt; output_edges = new ArrayList&lt;Edge&gt;();\n\n  // solange der wald nicht leer ist und der baum noch nicht alle knoten enth\u00e4lt\n  while (forest_edges.size() &gt; 0) {\n    // entferne eine kante (u, v) aus forest\n    Edge e = forest_edges.remove(0);\n\n    // finde die b\u00e4ume, die mit der Kante e verbunden sind\n    ArrayList&lt;Vertex&gt; tree_u = null;\n    ArrayList&lt;Vertex&gt; tree_v = null;\n    for (ArrayList&lt;Vertex&gt; t : forest) {\n      if (t.contains(getSourceVertexFromEdge(e, vertices)))\n        tree_u = t;\n      if (t.contains(getTargetVertexFromEdge(e, vertices)))\n        tree_v = t;\n    }\n\n    // Pr\u00fcfe ob die kante e von einem vertex ausgeht, der bereits mehr als 5 kanten\n    // hat\n    ArrayList&lt;Edge&gt; source_edges = getAdjacentEdges(e.getSource(), output_edges);\n    ArrayList&lt;Edge&gt; target_edges = getAdjacentEdges(e.getTarget(), output_edges);\n\n    if (source_edges.size() &gt;= max_edges || target_edges.size() &gt;= max_edges)\n      continue;\n\n    // wenn u und v in gleichen B\u00e4umen sind -&gt; skip\n    if (tree_u == tree_v)\n      continue;\n\n    // f\u00fcge kante von u und v zur Ausgabe hinzu\n    output_edges.add(e);\n\n    // f\u00fcge baum von v zu baum von u hinzu (merge)\n    for (Vertex v : tree_v)\n      tree_u.add(v);\n\n    forest.remove(tree_v);\n  }\n\n  // erstelle die Ausgabe-Adjazenzmatrix\n  int[][] output_matrix = new int[matrix.length][matrix.length];\n  for (Edge e : output_edges) {\n    int source = e.getSource() - 'A';\n    int target = e.getTarget() - 'A';\n    output_matrix[source][target] = matrix[source][target];\n    output_matrix[target][source] = matrix[target][source];\n  }\n  return output_matrix;\n}\n</code></pre>"},{"location":"Problem4/","title":"Problem 4 - \"Historische Funde\"","text":"<p>Beim Ausheben der Wege w\u00e4hrend des Stra\u00dfenbaus wurde ein antiker Feuerwerksplan gefunden. Die Lage der pyrotechnischen Effekte und die Z\u00fcndschn\u00fcre sind noch sehr gut zu erkennen.</p> <p>Wie aber ist die Choreographie des Feuerwerks? In welcher Reihenfolge z\u00fcnden die Bomben? K\u00f6nnen Sie den B\u00fcrgern der Graphschaft Schilda helfen? (Unter der Annahme, dass die Z\u00fcndschnur immer mit gleichbleibender Geschwindigkeit abbrennt...)</p>"},{"location":"Problem4/#modellierung-des-problems","title":"Modellierung des Problems","text":"<p>Das Problem l\u00e4sst sich als Graphenmodell mit ungerichteten Kanten darstellen. Das Steichholz und die Feuerwerksk\u00f6rper sind die Knoten, die Z\u00fcndschn\u00fcre sind die Kanten. Die Kosten der Kanten sind die L\u00e4nge der Z\u00fcndschn\u00fcre.</p> <p>Es wird die korrekte Reihenfolge gesucht, in der die Feuerwerksk\u00f6rper gez\u00fcndet werden wenn das Streichholz den ersten Feuerwerksk\u00f6rper z\u00fcndet.</p> <p>Um den Graph zu modellieren werden die Java-Bibliotheken <code>JGraphT</code> und <code>JGraphX</code> verwendet. Mit <code>JGraphT</code> wird der Graph als Datenstruktur modelliert. Mit <code>JGraphX</code> wird der Graph als Grafik dargestellt und auf dem Bildschirm dargestellt.</p>"},{"location":"Problem4/#die-eingabe","title":"Die Eingabe","text":"<p>Um das Bild der Aufgabenstellung in konkrete Daten zu \u00fcbersetzen, wurden hier Sch\u00e4tzungen der L\u00e4nge der Z\u00fcndschn\u00fcre vorgenommen und in einer Grafik dargestellt. Die Knoten wurden mit Buchstaben von A - I beschriftet.</p> <p>Die Eingabe besteht aus einem Graphen, der aus Kanten und Knoten besteht. Diese werden aus einer <code>.txt</code> Datei gelesen und in eine Instanz der Klasse <code>AdjazenzMatrix.java</code> geladen. Diese Instanz dient als Basis f\u00fcr die Berechnung des minimalen Spannbaums.</p>  <pre><code>// code/data/problem4.txt\n  A B C D E F G H I\nA 0\nB 1 0\nC 0 4 0\nD 0 1 2 0\nE 0 0 0 0 0\nF 0 4 0 3 3 0\nG 0 0 0 0 1 0 0\nH 0 0 0 0 3 0 4 0\nI 0 0 0 0 0 2 3 0 0\n</code></pre>"},{"location":"Problem4/#die-ausgabe","title":"Die Ausgabe","text":"<p>Die Ausgabe wird als Graph in einem Fenster dargestellt und in die Datei <code>4 Feuerwerksplaner.txt</code> geschrieben. Das Fenster besteht aus drei Teilen. Auf der linken Seite wird der Eingabegraph dargestellt. In der Mitte wird der berechnete Graph dargestellt mit dem k\u00fcrzesten Weg von A zu jedem anderen Knoten. Die Gewichte der Kanten zu den jeweiligen Knoten stellen die minimalen Gesamtkosten zum jeweiligen Knoten. Im rechten Teil wird eine Liste der Knoten dargestellt, in der die Knoten in der Reihenfolge aufgelistet sind, in der sie gez\u00fcndet werden.</p> <p>Ein korrekte Ausgabe erf\u00fcllt folgende Eigenschaften:</p> <ul> <li> <p>Die Kantengewichte m\u00fcssen die minimalen Gesamtkosten zum jeweiligen Knoten sein.</p> </li> <li> <p>Alle Knoten m\u00fcssen \u00fcber Kanten erreichbar sein.</p> </li> <li> <p>Der Graph muss zusammenh\u00e4ngend und zyklusfrei sein.</p> </li> <li> <p>Die Kanten m\u00fcssen ungerichtet sein.</p> </li> <li> <p>Alle Knoten des Eingabe-Graphen m\u00fcssen im Ausgabe-Graphen enthalten sein.</p> </li> </ul>  <pre><code>// code/output/4 Feuerwerksplaner.txt\n  A B C D E F G H I \nA 0 \nB 1 0 \nC 0 0 0 \nD 0 2 4 0 \nE 0 0 0 0 0 \nF 0 5 0 0 8 0 \nG 0 0 0 0 9 0 0 \nH 0 0 0 0 11 0 0 0 \nI 0 0 0 0 0 7 0 0 0 \n</code></pre>"},{"location":"Problem4/#geeignete-algorithmen","title":"Geeignete Algorithmen","text":"<p>F\u00fcr dieses Problem eignen sich die Algorithmen Dijkstra, Bellman-Ford und A*. </p> <p>Der Bellman-Ford-Algorithmus ist ein dynamischer Algorithmus, der iterativ die Entfernungen von dem Startknoten zu allen anderen Knoten im Graphen aktualisiert, bis sie stabil geworden sind. Der Dijkstra-Algorithmus hingegen ist ein statischer Algorithmus, der alle Entfernungen auf einmal berechnet.</p> <p>Der A Algorithmus ist ein Best-First-Suchalgorithmus, der dazu verwendet wird, den k\u00fcrzesten Pfad von einem Startknoten zu einem Zielknoten in einem Graphen zu finden. Der A-Algorithmus verwendet dabei eine Heuristik, um zu entscheiden, welche Knoten als n\u00e4chstes untersucht werden sollen. Diese Heuristik basiert auf einer Sch\u00e4tzung der Entfernung des Knotens vom Ziel und wird verwendet, um den Algorithmus dazu zu bringen, sich auf die Knoten zu konzentrieren, die wahrscheinlich zum Ziel f\u00fchren.</p>"},{"location":"Problem4/#die-laufzeit-des-algorithmus","title":"Die Laufzeit des Algorithmus","text":"<p>TODO</p>"},{"location":"Problem4/#die-implementierung-des-algorithmus","title":"Die Implementierung des Algorithmus","text":"<p>Zur L\u00f6sung des Problems wurde der Dijkstra-Algorithmus verwendet.  Der Dijkstra-Algorithmus ist ein Greedy-Algorithmus. </p> <p>Der Algorithmus verwendet dabei eine Priorit\u00e4tswarteschlange, um die Knoten zu sortieren, die als n\u00e4chstes untersucht werden sollen. Die Priorit\u00e4tswarteschlange wird mit den Knoten initialisiert, die direkt mit dem Startknoten verbunden sind. Die Knoten werden dann in der Priorit\u00e4tswarteschlange nach ihrer Entfernung vom Startknoten sortiert. Der Algorithmus w\u00e4hlt dann den Knoten mit der geringsten Entfernung aus der Priorit\u00e4tswarteschlange aus und aktualisiert die Entfernungen aller Knoten, die mit diesem Knoten verbunden sind. </p> <p>Dadurch bekommt jeder Knoten einen Wert, der die Entfernung vom Startknoten angibt. Der Algorithmus wird dann wiederholt, bis alle Knoten in der Priorit\u00e4tswarteschlange untersucht wurden.</p> <pre><code>private int[][] dijkstra(AdjazenzMatrix input) {\n\n  int[][] matrix = input.getMatrixCopy();\n  char[] vertexLetters = input.getVertexLetters();\n\n  // Generiere eine Liste aller Knoten\n  for (int i = 0; i &lt; matrix.length; i++)\n    vertices.add(new Vertex(vertexLetters[i], 0));\n\n  ArrayList&lt;Edge&gt; edges = getEdges(matrix, vertexLetters);\n\n  // Initialisiere die Distanz im Startknoten mit 0 und in allen anderen Knoten\n  // mit \u221e.\n  for (Vertex vertex : vertices) {\n    vertex.setKey(Integer.MAX_VALUE);\n    vertex.setPredecessor(null);\n  }\n  vertices.get(0).setKey(0);\n\n  // Speichere alle Knoten in einer Priorit\u00e4tswarteschlange queue\n  PriorityQueue&lt;Vertex&gt; queue = new PriorityQueue&lt;Vertex&gt;(\n      Comparator.comparingInt(Vertex::getKey));\n  queue.addAll(vertices);\n\n  // Solange es noch unbesuchte Knoten gibt, w\u00e4hle darunter denjenigen mit\n  // minimaler Distanz aus und\n  while (!queue.isEmpty()) {\n    // Nehme den Knoten mit dem kleinsten Wert aus der Warteschlange\n    Vertex v = queue.poll();\n\n    // 1. speichere, dass dieser Knoten schon besucht wurde\n    v.setVisited(true);\n\n    // 2. berechne f\u00fcr alle noch unbesuchten Nachbarknoten die Summe des jeweiligen\n    // Kantengewichtes und der Distanz im aktuellen Knoten\n    for (Vertex n : getNeighbors(v, vertices, edges)) {\n\n      // 3. ist dieser Wert f\u00fcr einen Knoten kleiner als die\n      // dort gespeicherte Distanz, aktualisiere sie und setze den aktuellen Knoten\n      // als Vorg\u00e4nger. (Dieser Schritt wird auch als Update bezeichnet. )\n      int sum = v.getKey() + getWeightSum(v, n, edges);\n\n      if (sum &gt;= n.getKey())\n        continue;\n\n      n.setKey((int) sum);\n      n.setPredecessor(v);\n      // Aktualisiere die Priorit\u00e4tswarteschlange\n      queue.remove(n);\n      queue.add(n);\n    }\n  }\n\n  // Sortiere Knoten nach Distanz\n  vertices.sort(Comparator.comparingInt(Vertex::getKey));\n\n  // Erstelle eine neue Adjazenzmatrix, die den jeweils k\u00fcrzesten Weg zu jedem\n  // Knoten enth\u00e4lt\n  int[][] matrix_output = new int[matrix.length][matrix.length];\n\n  for (Vertex vertex : vertices) {\n    if (vertex.getPredecessor() == null)\n      continue;\n    matrix_output[vertex.getPredecessor().getLetter() - 'A'][vertex.getLetter() - 'A'] = vertex.getKey();\n    matrix_output[vertex.getLetter() - 'A'][vertex.getPredecessor().getLetter() - 'A'] = vertex.getKey();\n  }\n\n  return matrix_output;\n}\n</code></pre>"},{"location":"Problem5/","title":"Problem 5 - \"Die Festhochzeit - das Verteilen der Einladungen\"","text":"<p>Zum gro\u00dfen Hochzeitfest in Schilda sollen nat\u00fcrlich alle Ortsbewohner eingeladen werden.</p> <p>Da in der letzten Zeit in Schilda viele neue Stra\u00dfen gebaut worden waren, muss der Brieftr\u00e4ger eine neue Route finden. Gl\u00fccklicherweise haben alle H\u00e4user ihre Briefk\u00e4sten an die neuen Stra\u00dfen gestellt, so dass der Brieftr\u00e4ger nur noch den k\u00fcrzesten Weg finden muss, der ausgehend von der Post durch alle Stra\u00dfen und dann wieder zur\u00fcck zur Post f\u00fchrt.</p> <p>Hier sind Sie wieder gefragt: Unterst\u00fctzen Sie den Brieftr\u00e4ger und entwerfen Sie die neue Route f\u00fcr den Brieftr\u00e4ger. Den Stadtplan kennen Sie ja bereits, schlie\u00dflich haben Sie die Stra\u00dfen gebaut.</p>"},{"location":"Problem5/#modellierung-des-problems","title":"Modellierung des Problems","text":""},{"location":"Problem5/#die-eingabe","title":"Die Eingabe","text":""},{"location":"Problem5/#die-ausgabe","title":"Die Ausgabe","text":""},{"location":"Problem5/#der-alrogithmus","title":"Der Alrogithmus","text":""},{"location":"Problem5/#die-laufzeit-des-algorithmus","title":"Die Laufzeit des Algorithmus","text":""},{"location":"Problem5/#die-implementierung-des-algorithmus","title":"Die Implementierung des Algorithmus","text":""},{"location":"Problem6/","title":"Problem 6 - \"Wohin nur mit den G\u00e4sten?\"","text":"<p>Zum Einweihungsfest werden zahlreiche ausw\u00e4rtige G\u00e4ste eingeladen. Reisen diese allerdings alle mit dem Auto an, dann ist ohne hervorragende Verkehrsplanung ein Stau in der Innenstadt vorprogrammiert. Parken k\u00f6nnen die Autos auf dem Parkplatz des neuen Supermarktes. </p> <p>Doch wie soll der Verkehr durch die Stadt geleitet werden, dass m\u00f6glichst viele Fahrzeuge von der Autobahn zum Parkplatz gelangen k\u00f6nnen, ohne dass sich lange Schlangen vor den Ampeln bilden? Die Kapazit\u00e4t der einzelnen Stra\u00dfen haben Ihnen die B\u00fcrger der Stadt bereits aufgezeichnet. </p> <p>Sie sollen nun planen, wie viele Wagen \u00fcber die einzelnen Wege geleitet werden sollen.</p>"},{"location":"Problem6/#modellierung-des-problems","title":"Modellierung des Problems","text":""},{"location":"Problem6/#die-eingabe","title":"Die Eingabe","text":""},{"location":"Problem6/#die-ausgabe","title":"Die Ausgabe","text":""},{"location":"Problem6/#der-alrogithmus","title":"Der Alrogithmus","text":""},{"location":"Problem6/#die-laufzeit-des-algorithmus","title":"Die Laufzeit des Algorithmus","text":""},{"location":"Problem6/#die-implementierung-des-algorithmus","title":"Die Implementierung des Algorithmus","text":""},{"location":"Problem7/","title":"Problem 7 - \"Es gibt viel zu tun! Wer macht's\"","text":"<p>W\u00e4hrend die B\u00fcrger der Stadt Schilda ganz begeistert von Ihnen sind, bekommen Sie immer mehr Auftr\u00e4ge, die Sie gar nicht mehr alleine bew\u00e4ltigen k\u00f6nnen. Sie stellen also neues Personal f\u00fcr die Projektleitung ein. Jeder Mitarbeiter hat unterschiedliche Kompetenzen und Sie wollen die Mitarbeiter so auf die Projekte verteilen, dass jedes Projekt von genau einem Mitarbeiter oder einer Mitarbeiterin mit den notwendigen Kompetenzen geleitet wird. </p> <p>Wie ordnen Sie die Mitarbeiter den Projekten zu? (Genau ein Mitarbeiter pro Projekt) (Auch diesen Algorithmus integrieren Sie in Ihr Tool \u2013 schlie\u00dflich m\u00f6chte auch die Graphschaft ihre Kr\u00e4fte gut einsetzen!)</p>"},{"location":"Problem7/#modellierung-des-problems","title":"Modellierung des Problems","text":""},{"location":"Problem7/#die-eingabe","title":"Die Eingabe","text":""},{"location":"Problem7/#die-ausgabe","title":"Die Ausgabe","text":""},{"location":"Problem7/#der-alrogithmus","title":"Der Alrogithmus","text":""},{"location":"Problem7/#die-laufzeit-des-algorithmus","title":"Die Laufzeit des Algorithmus","text":""},{"location":"Problem7/#die-implementierung-des-algorithmus","title":"Die Implementierung des Algorithmus","text":""}]}