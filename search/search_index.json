{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Die Graphschaft Schilda","text":""},{"location":"#abstract","title":"Abstract","text":"<p>Diese Website ist die Dokumentation des Projektes \"Graphschaft Schilda\" f\u00fcr das Modul Programmiertechnik III an der TH Aschaffenburg.</p> <p>Die Graphschaft Schilda ist ein beschauliches \u00d6rtchen irgendwo im Nichts. Lange Zeit blieb diese Graphschaft unbehelligt vom Fortschritt, nichts tat sich in dem  \u00d6rtchen. Eines Tages jedoch machte sich dort pl\u00f6tzlich das Ger\u00fccht breit, dass fernab der Graphschaft intelligente Menschen leben, die (fast) alle Probleme der Welt mit m\u00e4chtigen Algorithmen l\u00f6sen k\u00f6nnten. Die B\u00fcrger der Graphschaft machten sich also auf den Weg um diese intelligenten Menschen mit der L\u00f6sung ihrer Probleme zu beauftragen....</p>"},{"location":"#art-der-dokumentation","title":"Art der Dokumentation","text":"<p>Die Dokumentation des Projekts ist auf der Website schilda.node5.de zu finden. Alternativ wird automatisiert aus den Markdown-Dateien eine PDF-Dokumentation erstellt, die \u00fcber diesen Link herunter geladen werden kann.</p>"},{"location":"#aufgabenstellung","title":"Aufgabenstellung","text":"<p>Entwickeln Sie ein Planungstool, dass der Graphschaft Schilda bei der L\u00f6sung ihrer Probleme hilft.  </p> <ol> <li>Analysieren Sie jedes der Probleme: Welche Daten sollen verarbeitet werden? Was sind die Eingaben? Was die Ausgaben? Welcher Algorithmus eignet sich? Welche Datenstruktur eignet sich?</li> <li>Implementieren Sie den Algorithmus (in Java), so dass bei Eingabe der entsprechenden Daten die gew\u00fcnschte Ausgabe berechnet und ausgegeben wird. </li> <li>Geben Sie f\u00fcr jeden implementierten Algorithmus die Laufzeit an. Da Sie sich nun schon so viel M\u00fche mit dem Tool geben, wollen Sie das Tool nat\u00fcrlich auch an andere Gemeinden verkaufen. Die Eingaben sollen daf\u00fcr generisch, d.h., f\u00fcr neue Orte, Feiern und Planungen anpassbar sein. Sie k\u00f6nnen diese Aufgabe ein 2er oder 3er Teams l\u00f6sen. Bitte geben Sie dann die Arbeitsteilung im Dokument mit an. Die 15min\u00fctige Einzelpr\u00fcfung wird auf die Projektaufgabe eingehen.</li> </ol>"},{"location":"#rahmenbedingungen","title":"Rahmenbedingungen","text":""},{"location":"#eingabe","title":"Eingabe","text":"<p>Alle Algorithmen ben\u00f6tigen einen Graph als Eingabe und liefern einen Graph als Ausgabe. Die Testgraphen werden je nach Art des Graphen folgende Form haben:</p> <ol> <li>ungerichteter und ungewichteter Graph</li> <li>ungerichteter und gewichteter Graph</li> <li>gerichteter und ungewichteter Graph</li> <li>gerichteter und gewichteter Graph</li> </ol> <p>Alle Graphen werden als einfache Textdateien gegeben. Die erste Zeile beginnt mit zwei Leerzeichen, gefolgt von den Namen der Knoten, jeweils getrennt mit einem Leerzeichen. Alle weiteren Zeilen starten mit einem Knotennamen, gefolgt von einer Folge von Zahlen, jeweils getrennt durch ein Leerzeichen. F\u00fcr ungerichtete Graphen werden jeweils nur die Werte unterhalb der Diagonalen angegeben.</p> <p>Wichtig: Um neue Daten f\u00fcr die Eingabe zu verwenden, muss der Inhalt der txt-Dateien im Ordner \"code/data/problemX.txt\" ersetzt werden.</p>"},{"location":"#ausgabe","title":"Ausgabe","text":"<p>Die Ausgabe erfolgt in derselben Form wie die Eingabe.</p>"},{"location":"#abgabe-projekt","title":"Abgabe Projekt","text":"<p>Das Projekt ist als PDF-Datei mit folgender Benennung \"PT3-2022-FelixM\u00f6hler-JulianThiele.pdf\" bis zum 20.01.2023 abzugeben.</p>"},{"location":"#planungstool-aufbau","title":"Planungstool Aufbau","text":"<p>In den folgenden Abschnitten wird der Aufbau des Planungstools beschrieben.</p>"},{"location":"#ordnerstruktur-des-projektes","title":"Ordnerstruktur des Projektes","text":"<pre><code>GraphschafSchilda/\n\u251c\u2500 code/\n\u2502  \u251c\u2500 data/\n\u2502  \u2502  \u2514\u2500 Eingabe txt-Dateien\n\u2502  \u251c\u2500 output/\n\u2502  \u2502  \u2514\u2500 Ausgabe txt-Dateien\n\u2502  \u251c\u2500 old/\n\u2502  \u2502  \u2514\u2500 Fr\u00fchere Versionen der Algorithmen\n\u2502  \u251c\u2500 utils/\n\u2502  \u2502  \u251c\u2500 AdjazentMatrix.java\n\u2502  \u2502  \u251c\u2500 BasicWindow.java\n\u2502  \u2502  \u251c\u2500 Edge.java\n\u2502  \u2502  \u251c\u2500 FileHandler.java\n\u2502  \u2502  \u251c\u2500 JGraphPanel.java\n\u2502  \u2502  \u2514\u2500 Vertex.java\n\u2502  \u251c\u2500 Main.java\n\u2502  \u251c\u2500 Problem1.java\n\u2502  \u251c\u2500 Problem2.java\n\u2502  \u251c\u2500 Problem3.java\n\u2502  \u251c\u2500 Problem4.java\n\u2502  \u251c\u2500 Problem5.java\n\u2502  \u251c\u2500 Problem6.java\n\u2502  \u2514\u2500 Problem7.java\n\u251c\u2500 documentation/\n\u2502  \u2514\u2500 docs/\n\u2514\u2500 libs/\n</code></pre>"},{"location":"#das-interface","title":"Das Interface","text":"<p>Sobald das Programm startet, \u00f6ffnet sich ein Fenster mit einem Men\u00fc f\u00fcr die Auswahl der verschiedenen Probleme. Wenn ein Knopf gedr\u00fcckt wird, \u00f6ffnet sich ein neues Fenster mit dem entsprechenden Problem. </p> <p></p>"},{"location":"#die-aufgaben","title":"Die Aufgaben","text":"<p>Jedes Problem besitzt eine eigene Klasse <code>ProblemX.java</code>, die sich im Ordner <code>code</code> befinden. </p> <p>Der Ordner <code>code/utils</code> enth\u00e4lt die Klassen:</p> <ul> <li> <p><code>AdjazenzMatrix.java</code>: Speichert eine <code>int[][]</code> Matrix, <code>char[]</code> Buchstaben-Array und ob es sich um einen gerichteten oder ungerichteten Graphen handelt.</p> </li> <li> <p><code>FileHandler.java</code>: Stellt Methoden zum Einlesen und Schreiben von Dateien bereit. Die Laufzeit um eine Datei einzulesen ist <code>O(n)</code> mit n = Anzahl der Zeichen in der Datei. Die Laufzeit des Schreibens ist <code>O(V^2)</code> mit V = Anzahl der Knoten des Graphen.</p> </li> <li> <p><code>Vertex.java</code>: Speichert einen Buchstaben, einen Vertex-Vorg\u00e4nger, einen 'key' und eine Option ob der Vertex bereits besucht wurde.</p> </li> <li> <p><code>Edge.java</code>: Speichert zwei Buchstaben f\u00fcr den Start- und Endknoten der Kante und ein Gewicht.</p> </li> <li> <p><code>JGraphPanel.java</code>: Eine Klasse, die ein <code>JPanel</code> erweitert und mit Hilfe der mxgraph und jgrapht Bibliotheken einen Graphen zeichnet.</p> </li> <li> <p><code>BasicWindow.java</code>: Eine Klasse, die ein <code>JFrame</code> erweitert und als Grundlage f\u00fcr die Fenster der einzelnen Probleme dient.</p> </li> </ul>"},{"location":"#die-eingabe","title":"Die Eingabe","text":"<p>Die Eingabedateien befinden sich in dem Ordner <code>data</code> und folgen dem Namensschema <code>problemX.txt</code>. Die Dateien werden mit der Klasse <code>FileHandler.java</code> eingelesen und in einer Instanz der Klasse <code>AdjazenzMatrix.java</code> gespeichert. </p> <pre><code>Ungerichteter Graph      Gerichteter Graph\nA B C ...                A B C ...\nA 0                      A 0 0 1\nB 1 0                    B 0 0 1\nC 2 3 0                  C 1 0 0\n...                      ...\n</code></pre>"},{"location":"#die-ausgabe","title":"Die Ausgabe","text":"<p>Die Ausgabedateien befinden sich in dem Ordner <code>output</code> und werden automatisch generiert oder \u00fcberschrieben sobald ein Punkt aus dem Men\u00fc ausgew\u00e4hlt wird.</p> <p>Beim Bet\u00e4tigen eines Men\u00fcbuttons wird die Ein- und Ausgabe graphisch dargestellt und zus\u00e4tzlich in der Konsole ausgegeben.</p> <p>In der Ausgabedatei werden die Graphen in einer Adjazenzmatrix gespeichert, die dem Schema der Eingabedatei entspricht. </p>"},{"location":"#das-team","title":"Das Team","text":"<p>Felix M\u00f6hler - GitHub - Aufgabenteilung: Dokumentation und Code f\u00fcr Problem 2, 5, 6 und </p> <p>Julian Thiele - GitHub - Aufgabenteilung: Dokumentation und Code f\u00fcr Problem 1, 3, 4, 6 und 7</p>"},{"location":"#auftraggeber","title":"Auftraggeber","text":"<p>Prof. Barbara Sprick - Professorin f\u00fcr Praktische Informatik bei TH Aschaffenburg</p>"},{"location":"Problem1/","title":"Problem 1 - \"Stra\u00dfen m\u00fcssen her!\"","text":"<p>Lange Zeit gab es in der Graphschaft Schilda einen Reformstau, kein Geld floss mehr in die Infrastruktur. Wie es kommen musste, wurde der Zustand der Stadt zusehends schlechter, bis die B\u00fcrger der Graphschaft den Aufbau Ihrer Stadt nun endlich selbst in die Hand nahmen. Zun\u00e4chst einmal sollen neue Stra\u00dfen gebaut werden. Zur Zeit gibt es nur einige schlammige Wege zwischen den H\u00e4usern. Diese sollen nun gepflastert werden, so dass von jedem Haus jedes andere Haus erreichbar ist. </p> <p>Da die B\u00fcrger der Stadt arm sind, soll der Stra\u00dfenbau insgesamt m\u00f6glichst wenig kosten. Die B\u00fcrger haben bereits einen Plan mit m\u00f6glichen Wegen erstellt. Ihre Aufgabe ist nun, das kosteng\u00fcnstigste Wegenetz zu berechnen, so dass alle H\u00e4user miteinander verbunden sind (nehmen Sie dabei pro Pflasterstein Kosten von 1 an):</p>"},{"location":"Problem1/#modellierung-des-problems","title":"Modellierung des Problems","text":"<p>Das Problem l\u00e4sst sich als Graphenmodell mit ungerichteten Kanten darstellen. Jedes Haus ist ein Knoten, die Stra\u00dfen sind die Kanten. Die Kosten der Kanten sind die Kosten f\u00fcr die Pflastersteine. </p> <p>Es wird eine Konfiguration an Kanten gesucht, die eine minimale Anzahl an Pflastersteinen ben\u00f6tigt.</p> <p>Um den Graph zu modellieren werden die Java-Bibliotheken <code>JGraphT</code> und <code>JGraphX</code> verwendet. Mit <code>JGraphT</code> wird der Graph als Datenstruktur modelliert. Mit <code>JGraphX</code> wird der Graph als Grafik dargestellt und auf dem Bildschirm dargestellt.</p>"},{"location":"Problem1/#die-eingabe","title":"Die Eingabe","text":"<p>Die Eingabe besteht aus einem Graphen, der aus Kanten und Knoten besteht. Diese werden aus einer <code>.txt</code> Datei gelesen und in eine Instanz der Klasse <code>AdjazenzMatrix.java</code> geladen. Diese Instanz dient als Basis f\u00fcr die Berechnung des minimalen Spannbaums.</p> <p>Das Bild aus der Aufgabenstellung wurde mit Buchstaben von A bis J beschriftet und daraus wurde die Datei <code>problem1.txt</code> erstellt.</p> <p></p> <pre><code>// code/data/problem1.txt\nA B C D E F G H I J\nA 0\nB 5 0\nC 3 3 0\nD 0 3 0 0\nE 4 0 5 0 0\nF 0 2 3 0 0 0\nG 0 0 4 0 4 4 0\nH 0 0 0 0 2 0 3 0\nI 0 0 0 0 0 3 2 4 0\nJ 0 4 0 2 0 3 0 0 4 0\n</code></pre>"},{"location":"Problem1/#die-ausgabe","title":"Die Ausgabe","text":"<p>Die Ausgabe wird als Graph in einem Fenster dargestellt und in die Datei <code>1 Stra\u00dfenplaner.txt</code> geschrieben. Das Fenster besteht aus zwei H\u00e4lften. Auf der linken Seite wird der Eingabegraph dargestellt. Auf der rechten Seite wird der berechnete Graph dargestellt. </p> <p>Eine korrekte Ausgabe erf\u00fcllt folgende Eigenschaften:</p> <ul> <li> <p>Die Summe der Kantengewichte muss minimal sein.</p> </li> <li> <p>Alle Knoten m\u00fcssen \u00fcber Kanten erreichbar sein.</p> </li> <li> <p>Der Graph muss zusammenh\u00e4ngend und zyklusfrei sein.</p> </li> <li> <p>Die Kanten m\u00fcssen ungerichtet sein.</p> </li> <li> <p>Alle Knoten des Eingabe-Graphen m\u00fcssen im Ausgabe-Graphen enthalten sein.</p> </li> </ul> <p></p> <pre><code>// code/output/1 Stra\u00dfenplaner.txt\nA B C D E F G H I J A 0 B 0 0 C 3 3 0 D 0 3 0 0 E 0 0 0 0 0 F 0 2 0 0 0 0 G 0 0 0 0 0 0 0 H 0 0 0 0 2 0 3 0 I 0 0 0 0 0 3 2 0 0 J 0 0 0 2 0 0 0 0 0 0 </code></pre>"},{"location":"Problem1/#geeignete-algorithmen","title":"Geeignete Algorithmen","text":"<p>Es gibt verschiedene Algorithmen, die verwendet werden k\u00f6nnen, um den minimalen Spannbaum eines ungerichteten Graphen zu berechnen. Einige dieser Algorithmen sind:</p> <p>Kruskal-Algorithmus: Dieser Algorithmus sortiert alle Kanten des Graphen nach ihrem Gewicht und f\u00fcgt sie dann eine nach der anderen dem minimalen Spannbaum hinzu, wobei sichergestellt wird, dass keine Schleife entsteht. Der Algorithmus endet, wenn alle Knoten des Graphen Teil des Spannbaums sind.</p> <p>Prim-Algorithmus: Dieser Algorithmus beginnt mit einem beliebigen Knoten des Graphen und f\u00fcgt nacheinander Kanten hinzu, die den aktuellen minimalen Spannbaum mit einem neuen Knoten verbinden. Der Algorithmus endet, wenn alle Knoten des Graphen Teil des Spannbaums sind.</p>"},{"location":"Problem1/#die-laufzeit-des-algorithmus","title":"Die Laufzeit des Algorithmus","text":"<p>Die Laufzeit der Funktion <code>prim()</code> h\u00e4ngt von der Anzahl der Knoten (V) und der Anzahl der Kanten (E) im Graph ab. </p> <p>Die Funktion <code>getEdges(matrix, vertexLetters)</code> hat eine Laufzeit von O(V^2), da sie eine Schleife \u00fcber alle V^2 m\u00f6glichen Kanten des Graphs durchf\u00fchrt. </p> <p>Die Funktion <code>getNeighbors(u, vertices, edges)</code> hat eine Laufzeit von O(V * E), da sie eine Schleife \u00fcber alle V Vertices und eine Schleife \u00fcber alle E Kanten durchf\u00fchrt, um alle Nachbarn von u zu finden.</p> <p>Die while-Schleife hat eine Laufzeit von O(V), da alle Knoten in der Priorit\u00e4tswarteschlange einmal durchlaufen werden k\u00f6nnen. Innerhalb der while-Schleife wird ein Element aus der Warteschlange genommen O(log(V)) und die Funktion <code>getNeighbors()</code> aufgerufen. </p> <p>Daraus resultiert eine Laufzeit von O(V^2) + O(V) * ( O(log(V) + O(V * E) ). Umgeformt ergibt sich eine Laufzeit von O(V^2 + V^2 * E + V * log(V)).</p> <p>Dies kann auf O(V^2 * E) vereinfacht werden.</p>"},{"location":"Problem1/#die-implementierung-des-algorithmus","title":"Die Implementierung des Algorithmus","text":"<p>Zur L\u00f6sung des Problems wurde der Algorithmus von Prim implementiert. Der Algorithmus von Prim ist ein Greedy-Algorithmus. Als Datenstruktur wurde eine Priorit\u00e4tswarteschlange verwendet, die Instanzen der Klasse <code>Vertex</code> beinhaltet: </p> <p>Zuerst wird eine Liste aller Knoten und Kanten erstellt. Die Knoten werden mit dem maximalen Wert f\u00fcr Integer und ohne Vorg\u00e4nger initialisiert. Anschlie\u00dfend wird ein beliebiger Knoten als Startknoten gew\u00e4hlt (In diesem Fall der Erste). Der Startknoten bekommt den Wert <code>0</code>. Alle Knoten werden in eine Priorit\u00e4tswarteschlange <code>Q</code> eingef\u00fcgt.</p> <p>Danach wird eine while-Schleife verwendet um alle Knoten zu durchlaufen. In der Schleife wird der Knoten mit dem kleinsten Wert aus der Warteschlange <code>Q</code> entfernt. Anschlie\u00dfend wird f\u00fcr jeden Nachbarknoten des aktuellen Knotens \u00fcberpr\u00fcft, ob der Wert des Nachbarknotens gr\u00f6\u00dfer als der Wert des aktuellen Knotens plus der Kosten der Kante ist. Wenn dies der Fall ist, wird der Wert des Nachbarknotens auf den Wert des aktuellen Knotens plus die Kosten der Kante gesetzt und der Vorg\u00e4nger des Nachbarknotens auf den aktuellen Knoten gesetzt.</p> <p>Am Ende wird die Liste aller Knoten in eine Adjazenzmatrix umgewandelt und zur\u00fcckgegeben.</p> <pre><code>private int[][] prim(int[][] matrix, char[] vertexLetters) {\nArrayList&lt;Vertex&gt; vertices = new ArrayList&lt;&gt;();\nArrayList&lt;Edge&gt; edges = getEdges(matrix, vertexLetters); // O(V^2)\n// Generiere eine Liste aller Knoten mit dem Wert unendlich und ohne Vorg\u00e4nger\nfor (int i = 0; i &lt; matrix.length; i++)\nvertices.add(new Vertex(vertexLetters[i], Integer.MAX_VALUE, null));\n// Starte mit beliebigem Startknoten, Startknoten bekommt den Wert 0\nvertices.get(0).setKey(0);\n// Speichere alle Knoten in einer geeigneten Datenstruktur Q\n// -&gt; Priorit\u00e4tswarteschlange\nPriorityQueue&lt;Vertex&gt; q = new PriorityQueue&lt;&gt;(Comparator.comparingInt(Vertex::getKey));\nq.addAll(vertices);\n// Solange es noch Knoten in Q gibt...\nwhile (!q.isEmpty()) {\n// Entnehme den Knoten mit dem kleinsten Wert\nVertex u = q.poll();\n// F\u00fcr jeden Nachbarn n von u\nfor (Vertex n : getNeighbors(u, vertices, edges)) { // O(V * E)\n// Finde die Kante (u, n)\nEdge e = null;\nfor (Edge edge : edges)\nif ((edge.getSource() == u.getLetter() &amp;&amp; edge.getTarget() == n.getLetter())\n|| (edge.getSource() == n.getLetter() &amp;&amp; edge.getTarget() == u.getLetter()))\ne = edge;\n// Wenn n in Q und das Gewicht der Kante (u, n) kleiner ist als der Wert von n\nif (!q.contains(n) || e.getWeight() &gt;= n.getKey())\ncontinue;\n// Setze den Wert von n auf das Gewicht der Kante (u, n)\nn.setKey(e.getWeight());\n// Setze den Vorg\u00e4nger von n auf u\nn.setPredecessor(u);\n// Aktualisiere die Position von n in Q\nq.remove(n);\nq.add(n);\n}\n}\n// Erstelle die Adjazenzmatrix f\u00fcr den Minimum Spanning Tree\nint[][] matrix_output = new int[matrix.length][matrix.length];\nfor (Vertex v : vertices) {\nif (v.getPredecessor() == null)\ncontinue;\nint i = v.getLetter() - 'A';\nint j = v.getPredecessor().getLetter() - 'A';\nmatrix_output[i][j] = matrix[i][j];\nmatrix_output[j][i] = matrix[j][i];\n}\nreturn matrix_output;\n}\n</code></pre>"},{"location":"Problem2/","title":"Problem 2 - \"Wasserversorgung\"","text":"<p>Der Stra\u00dfenbau in der Graphschaft Schilda war erfolgreich, die Stadt bl\u00fcht und gedeiht wieder! Selbst ein neuer Supermarkt soll er\u00f6ffnet werden. Nun muss dieser aber mit Wasser versorgt werden, und da Sie bereits das Stra\u00dfenbauprojekt so erfolgreich durchgef\u00fchrt haben, werden Sie nun auch damit beauftragt, den neuen Supermarkt an die Wasserversorgung anzuschlie\u00dfen.</p> <p>Da die Stadt nach wie vor kein Geld verschwenden m\u00f6chte, m\u00fcssen Sie zun\u00e4chst feststellen, ob das bestehende Leitungsnetz noch ausreichend Kapazit\u00e4t f\u00fcr den zus\u00e4tzlichen Wasserverbrauch hat, oder ob neue Leitungen ben\u00f6tigt werden. Da die Graphschaft Schilda noch keine Pumpen kennt, kann das Wasser nur bergab flie\u00dfen. Als Vorarbeit haben Ihnen die B\u00fcrger die bestehende Wasserversorgung und die Lage des neuen Supermarktes aufgezeichnet:</p>"},{"location":"Problem2/#modellierung-des-problems","title":"Modellierung des Problems","text":"<p>Das Problem l\u00e4sst sich als Graphenmodell mit gerichteten und gewichteten Kanten darstellen. Jedes Haus ist ein Knoten, die Wasserleitungen zwischen den H\u00e4usern sind die Kanten. Das Gewicht der Kanten wird durch den maximal m\u00f6glichen Volumenstrom in m^3/s dargestellt.</p> <p>Es wird nach dem maximalen Fluss im gegebenen Flussnetzwerk von einer Quelle zu einer Senke gesucht.</p> <p>Durch die Kombination der Kanten von einer Quelle (Startpunkt) zu einer Senke (Endpunkt) erh\u00e4lt man m\u00f6gliche Flusspfade. Wenn ein Pfad gefunden wurde, wird das maximal m\u00f6gliche Kantengewicht (Gewicht der kleinsten Kante) von allen Kanten aus dem Pfad abgezogen. Dieser Vorgang wird so lange wiederholt, bis es keinen m\u00f6glichen Flusspfad mit freier Kapazit\u00e4t von der Quelle zur Senke mehr gibt. Die einzelnen m\u00f6glichen Flusspfade werden zu einem Gesamtdurchfluss addiert. Durch Verwenden des Edmonds-Karp-Algorithmus wird stehts der k\u00fcrzeste Weg mit freien Kapazit\u00e4ten gew\u00e4hlt und somit auch das schnellstm\u00f6gliche Abarbeiten des Graphen gew\u00e4hrleistet.</p> <p>Um den Graph zu modellieren werden die Java-Bibliotheken <code>JGraphT</code> und <code>JGraphX</code> verwendet. Mit <code>JGraphT</code> wird der Graph als Datenstruktur modelliert. Mit <code>JGraphX</code> wird der Graph als Grafik dargestellt und auf dem Bildschirm dargestellt.</p>"},{"location":"Problem2/#die-eingabe","title":"Die Eingabe","text":"<p>Die Eingabe besteht aus einem Graphen, der aus Kanten und Knoten besteht. Diese werden aus einer <code>.txt</code> Datei gelesen und in eine Instanz der Klasse <code>AdjazenzMatrix.java</code> geladen. Diese Instanz dient als Basis f\u00fcr die Berechnung des maximalen Flusses von Quelle zu Senke.</p> <p>F\u00fcr die Matrix in der Datei <code>problem2.txt</code> wurden jeweils die Anfangsbuchstaben W, A, B, C, D, H, I, T, S, der Geb\u00e4ude aus dem Bild als Bezeichnung genutzt. Wobei W f\u00fcr das Wasserwerk als Quelle steht und S f\u00fcr den Supermarkt als Senke.</p> <p></p> <pre><code>// code/data/problem2.txt\nW A B C D H I T S\nW 0 0 0 12 0 0 6 15 0\nA 0 0 0 0 0 0 0 0 10\nB 0 0 0 0 0 0 0 0 10\nC 0 5 0 0 0 5 0 0 0\nD 0 5 6 0 0 0 0 0 0\nH 0 0 0 0 0 0 0 0 7\nI 0 0 3 0 0 1 0 0 0\nT 0 0 0 0 8 0 0 0 0\nS 0 0 0 0 0 0 0 0 0 </code></pre>"},{"location":"Problem2/#die-ausgabe","title":"Die Ausgabe","text":"<p>Die Ausgabe wird als Graph in einem Fenster dargestellt und in die Datei <code>2 Wasserversorgungsplaner.txt</code> geschrieben. Die erzeugte Datei wird im Projekt im Ordner <code>output</code> abgelegt und kann mit einem Text Editor ge\u00f6ffnet werden. Das Fenster zur Visualisierung der Graphen besteht aus zwei H\u00e4lften. Auf der linken Seite wird der Eingabegraph dargestellt. Auf der rechten Seite wird der berechnete Ausgabegraph dargestellt. In diesem Graph entsprechen die Werte der Kanten dem maximal nutzbaren Volumenstrom pro Kante von Wasserwerk zu Supermarkt.</p> <p>Eine korrekte Ausgabe erf\u00fcllt folgende Eigenschaften:</p> <ul> <li> <p>Der Fluss von Quelle zu Senke muss maximal sein</p> </li> <li> <p>Alle nutzbaren Pfade f\u00fcr Fl\u00fcsse m\u00fcssen gefunden werden</p> </li> <li> <p>Der maximal m\u00f6gliche Fluss pro Pfad muss von den Pfadkanten abgezogen werden</p> </li> <li> <p>Die Kanten m\u00fcssen gerichtet sein und der R\u00fcckfluss aus dem Ausgabegraph entfernt</p> </li> <li> <p>Es muss ersichtlich sein welcher Volumenstrom an der Quelle m\u00f6glich ist</p> </li> </ul> <p></p> <pre><code>// code/data/2 Wasserversorgungsplaner.txt\nW A B C D H I T S W 0 0 0 10 0 0 4 8 0 A 0 0 0 0 0 0 0 0 10 B 0 0 0 0 0 0 0 0 6 C 0 5 0 0 0 5 0 0 0 D 0 5 3 0 0 0 0 0 0 H 0 0 0 0 0 0 0 0 6 I 0 0 3 0 0 1 0 0 0 T 0 0 0 0 8 0 0 0 0 S 0 0 0 0 0 0 0 0 0 </code></pre>"},{"location":"Problem2/#geeignete-algorithmen","title":"Geeignete Algorithmen","text":"<p>Es gibt verschiedene Algorithmen, die verwendet werden k\u00f6nnen, um den maximalen Fluss in einem gerichteten Graph zu berechnen. Einige dieser Algorithmen sind:</p> <p>Ford-Fulkerson-Algorithmus: Dieser Algorithmus ist ein iterativer Algorithmus, der in jedem Schritt den Fluss durch einen Pfad erh\u00f6ht, der vom Quellknoten zum Zielknoten f\u00fchrt und dessen Kapazit\u00e4t noch nicht vollst\u00e4ndig ausgesch\u00f6pft ist. Der Algorithmus endet, wenn kein solcher Pfad mehr existiert.</p> <p>Dinic-Algorithmus: Dieser Algorithmus ist ebenfalls ein iterativer Algorithmus, der den Fluss durch den Graph in jedem Schritt erh\u00f6ht, indem er einen Pfad vom Quellknoten zum Zielknoten sucht, dessen Kapazit\u00e4t noch nicht vollst\u00e4ndig ausgesch\u00f6pft ist. Im Gegensatz zum Ford-Fulkerson-Algorithmus verwendet der Dinic-Algorithmus jedoch eine Heuristik, um schneller zum Ergebnis zu gelangen.</p> <p>Edmonds-Karp-Algorithmus: Dieser Algorithmus ist eine Variation des Ford-Fulkerson-Algorithmus und verwendet auch eine Heuristik, um schneller zum Ergebnis zu gelangen. Im Gegensatz zum Dinic-Algorithmus verwendet der Edmonds-Karp-Algorithmus jedoch eine Breitensuche statt einer Tiefensuche, um Pfade im Graph zu finden.</p> <p>Preflow-Push-Algorithmus: Dieser Algorithmus ist ein schneller, parallelisierbarer Algorithmus, der den Fluss durch den Graph in jedem Schritt erh\u00f6ht, indem er einen Pfad vom Quellknoten zum Zielknoten sucht, dessen Kapazit\u00e4t noch nicht vollst\u00e4ndig ausgesch\u00f6pft ist. Im Gegensatz zu den anderen Algorithmen, die hier aufgef\u00fchrt sind, ist der Preflow-Push-Algorithmus jedoch nicht iterativ, sondern arbeitet in einem einzelnen Durchgang.</p>"},{"location":"Problem2/#die-laufzeit-des-algorithmus","title":"Die Laufzeit des Algorithmus","text":"<p>Die Laufzeit der Funktion <code>bfs()</code> ist O(V + E). In jedem Schritt wird ein Knoten aus der Warteschlange entfernt und die Nachbarknoten des Knotens werden in die Warteschlange aufgenommen. Da jeder Knoten nur einmal in die Warteschlange aufgenommen wird und jede Kante nur einmal betrachtet wird, betr\u00e4gt die Laufzeit O(V + E).</p> <p>Die Laufzeit des Ford-Fulkerson-Algorithmus ist O(V * E^2). Der Algorithmus wird in jedem Schritt iterativ ausgef\u00fchrt, bis kein Pfad mehr vom Quellknoten zum Zielknoten verf\u00fcgbar ist, der dessen Kapazit\u00e4t noch nicht vollst\u00e4ndig ausgesch\u00f6pft hat. In jedem Schritt wird eine Breitensuche ausgef\u00fchrt, um einen solchen Pfad zu finden.</p> <p>Da am Ende der <code>fordFulkerson(int[][] matrix)</code> Funktion noch eine Ausgabematrix erzeugt wird erh\u00f6ht sich die Laufzeit um O(V^2). Mit der gleichen Laufzeit werden zus\u00e4tzlich noch die inversen Kanten des Graphen entfernt.</p> <pre><code>// Filtere die inversen Kanten\nfor (int i = 0; i &lt; matrix_output.length; i++)\nfor (int j = 0; j &lt; matrix_output[i].length; j++)\nif (matrix_output[i][j] &lt; 0)\nmatrix_output[i][j] = 0;\n</code></pre> <p>Daraus folgt eine Laufzeit von O(V * E^2 + V^2).</p>"},{"location":"Problem2/#die-implementierung-des-algorithmus","title":"Die Implementierung des Algorithmus","text":"<p>Zur L\u00f6sung des Problems wurde der Ford-Fulkerson-Algorithmus verwendet. Genauer gesagt wurde der Edmonds-Karp-Algorithmus verwendet, da dieser eine Breitensuche verwendet, um Pfade im Graph zu finden.  </p> <p>Zuerst wird die Matrix <code>matrix</code> in eine echte Kopie <code>output</code> kopiert. Die echte Kopie wird sp\u00e4ter als Ausgabe verwendet.</p> <p>Danach wird ein Eltern-Array <code>parent</code> erstellt, das die Elternknoten der Knoten im Graph speichert. Dieses Array wird sp\u00e4ter verwendet, um den Pfad vom Quellknoten zum Zielknoten zu finden.</p> <p>Als n\u00e4chstes wird eine Breitensuche ausgef\u00fchrt, um einen Pfad vom Quellknoten zum Zielknoten zu finden, dessen Kapazit\u00e4t noch nicht vollst\u00e4ndig ausgesch\u00f6pft ist. Die Breitensuche wird durch die Funktion <code>bfs()</code> ausgef\u00fchrt. Die Funktion <code>bfs()</code> gibt <code>true</code> zur\u00fcck, wenn ein Pfad gefunden wurde, der vom Quellknoten zum Zielknoten f\u00fchrt und dessen Kapazit\u00e4t noch nicht vollst\u00e4ndig ausgesch\u00f6pft ist. Andernfalls wird <code>false</code> zur\u00fcckgegeben.</p> <p>Als Datenstruktur der <code>bfs()</code> Funktion wird eine LinkedList verwendet. Die Laufzeit der <code>poll()</code> Funktion betr\u00e4gt O(1), da die LinkedList eine doppelt verkettete Liste ist. Die Laufzeit der <code>add()</code> Funktion betr\u00e4gt ebenfalls O(1), da die LinkedList eine doppelt verkettete Liste ist.</p> <p>Wenn ein solcher Pfad gefunden wurde, wird der minimale Fluss des Pfades berechnet. Der minimale Fluss des Pfades ist die kleinste Kapazit\u00e4t, die noch nicht vollst\u00e4ndig ausgesch\u00f6pft ist. Dieser Wert wird dann zum maximalen Fluss des Graphen addiert. </p> <p>Zuletzt wird eine neue Ausgabematrix erstellt, die nur aus dem positiven Fluss des Graphen besteht. </p> <pre><code>/**\n * Laufzeit: O(V * E^2 + V^2)\n * \n * @param matrix\n * @return\n */\nprivate int[][] fordFulkerson(int[][] matrix) {\n// Anzahl der Knoten im Graph\nint nodes = matrix[0].length;\n// Die Quelle is der erste Knoten\nint source = 0;\n// Die Senke ist der letzte Knoten\nint sink = nodes - 1;\n// Flow ist zu Beginn 0\nmax_flow = 0;\nint u, v;\n// Erzeuge echte Kopie der Matrix f\u00fcr Output\nint output[][] = new int[nodes][nodes];\nfor (u = 0; u &lt; nodes; u++)\nfor (v = 0; v &lt; nodes; v++)\noutput[u][v] = matrix[u][v];\n// Erzeuge ein Eltern Array zum speichern der m\u00f6glichen BFS-Pfade\nint parent[] = new int[nodes];\n// Wenn f\u00fcr einen Pfad der BFS m\u00f6glich ist, \u00fcberpr\u00fcfe seinen maximalen Fluss\nwhile (bfs(matrix, output, source, sink, parent)) {\n// Setze den Pfad Fluss auf unendlich\nint path_flow = Integer.MAX_VALUE;\n// Finde den maximalen Fluss durch die m\u00f6glichen Pfade\nfor (u = sink; u != source; u = parent[u]) {\nv = parent[u];\npath_flow = Math.min(path_flow, output[v][u]);\n}\n// aktualisiere die Kanten aus dem Eltern Array\nfor (u = sink; u != source; u = parent[u]) {\nv = parent[u];\n// Ziehe den Fluss-Pfad den Kanten ab\noutput[v][u] -= path_flow;\n// Addiere den Fluss-Pfad auf die Inversen Kanten\noutput[u][v] += path_flow;\n}\n// Addiere die einzelnen Flusspfade auf den maximalen Fluss\nmax_flow += path_flow;\n}\n// Ziehe von der Eingabe Matrix die \u00fcbrigen Flussgewichte ab\nint[][] outputGraph = new int[nodes][nodes];\nfor (int i = 0; i &lt; matrix[0].length; i++)\nfor (int j = 0; j &lt; matrix[0].length; j++)\noutputGraph[i][j] = matrix[i][j] - output[i][j];\nreturn outputGraph;\n}\n/**\n * Laufzeit: O(V + E)\n * \n * @param matrix\n * @param output\n * @param s\n * @param t\n * @param parent\n * @return\n */\nprivate boolean bfs(int[][] matrix, int output[][], int s, int t, int parent[]) {\n// Anzahl der Knoten im Graph\nint nodes = matrix[0].length;\n// Array das alle Knoten als nicht besucht markiert\nboolean visited[] = new boolean[nodes];\nfor (int i = 0; i &lt; nodes; ++i)\nvisited[i] = false;\n// Warteschlange, die besuchte Knoten als true markiert\nLinkedList&lt;Integer&gt; queue = new LinkedList&lt;Integer&gt;();\nqueue.add(s);\nvisited[s] = true;\nparent[s] = -1;\n// Standard BFS-Loop, entfernt Knoten aus der Warteschlange die ungleich 0 sind\nwhile (queue.size() != 0) {\nint u = queue.poll();\nfor (int v = 0; v &lt; nodes; v++) {\nif (visited[v] == false &amp;&amp; output[u][v] &gt; 0) {\n// Wenn wir einen m\u00f6glichen Pfad von s nach t finden geben wir true zur\u00fcck\nif (v == t) {\nparent[v] = u;\nreturn true;\n}\n// Wenn wir keinen m\u00f6glichen Pfad finden f\u00fcgen wir den Knoten zur Warteschlange\n// und markieren ihn als besichtigt\nqueue.add(v);\nparent[v] = u;\nvisited[v] = true;\n}\n}\n}\nreturn false;\n}\n</code></pre>"},{"location":"Problem3/","title":"Problem 3 - \"Stromversorgung\"","text":"<p>Die Stadt floriert, alles wird moderner und so muss auch die Stromversorgung erneuert werden. Die Stadt hat bereits eruiert, wo Strommasten aufgestellt werden k\u00f6nnen. Sie haben auch festgestellt, dass es keine Barrieren in der Stadt gibt, d.h., prinzipiell k\u00f6nnten alle Strommasten miteinander verbunden werden. Aber nat\u00fcrlich wollen wir lange Leitungen m\u00f6glichst vermeiden. </p> <p>Deswegen schr\u00e4nken wir von vornherein ein, dass jeder Strommast nur mit maximal 5 n\u00e4chsten Nachbarn verbunden werden darf.  Es stellt sich heraus, dass dies immer noch zu teuer ist. Deswegen soll dieses Netz noch einmal so reduziert werden, dass zwar alle Strommasten miteinander verbunden sind, aber Kosten insgesamt minimal sind. Wir nehmen dabei an, dass die Kosten ausschlie\u00dflich von der Leitungsl\u00e4nge abh\u00e4ngen. </p>"},{"location":"Problem3/#modellierung-des-problems","title":"Modellierung des Problems","text":"<p>Das Problem l\u00e4sst sich als Graphenmodell mit ungerichteten Kanten darstellen. Jeder Strommast ist ein Knoten, die Verbindungen sind die Kanten. Die Kosten der Kanten sind die L\u00e4nge der Stromleitungen. </p> <p>Es wird eine Konfiguration an Leitungen zwischen den Strommasten gesucht, die eine minimale Gesamtl\u00e4nge besitzt, und jeder Strommast mit maximal mit 5 weiteren Masten verbunden sein darf.</p> <p>Um den Graph zu modellieren werden die Java-Bibliotheken <code>JGraphT</code> und <code>JGraphX</code> verwendet. Mit <code>JGraphT</code> wird der Graph als Datenstruktur modelliert. Mit <code>JGraphX</code> wird der Graph als Grafik dargestellt und auf dem Bildschirm dargestellt.</p>"},{"location":"Problem3/#die-eingabe","title":"Die Eingabe","text":"<p>Die Eingabe besteht aus einem Graphen, der aus Kanten und Knoten besteht. Diese werden aus einer <code>.txt</code> Datei gelesen und in eine Instanz der Klasse <code>AdjazenzMatrix.java</code> geladen. Diese Instanz dient als Basis f\u00fcr die Berechnung des minimalen Spannbaums.</p> <p>Der Eingabegraph besteht aus 12 Knoten und 66 Kanten. Die Kanten werden mit aufsteigenden Gewichten generiert. Die Knoten werden mit Buchstaben von A - L bezeichnet.</p> <p>Zus\u00e4tzlich ist im Code hinterlegt, dass die maximale Anzahl an Nachbarn pro Knoten 5 ist.</p> <pre><code>// code/data/problem3.txt\nA B C D E F G H I J K L\nA 0\nB 1 0\nC 2 3 0\nD 4 5 6 0\nE 7 7 9 10 0\nF 11 12 13 14 15 0\nG 16 17 18 19 20 21 0\nH 22 23 24 25 26 27 28 0\nI 29 30 31 32 33 34 35 36 0\nJ 37 38 39 40 41 42 43 44 45 0\nK 46 47 48 49 50 51 52 53 54 55 0\nL 56 57 58 59 60 61 62 63 64 65 66 0\n</code></pre>"},{"location":"Problem3/#die-ausgabe","title":"Die Ausgabe","text":"<p>Die Ausgabe wird als Graph in einem Fenster dargestellt und in die Datei <code>3 Stromversorgung.txt</code> geschrieben. Das Fenster besteht aus zwei H\u00e4lften. Auf der linken Seite wird der Eingabegraph dargestellt. Auf der rechten Seite wird der berechnete Graph dargestellt. </p> <p>Ein korrekte Ausgabe erf\u00fcllt folgende Eigenschaften:</p> <ul> <li> <p>Die Summe der Kantengewichte muss minimal sein.</p> </li> <li> <p>Die Anzahl der Kanten darf maximal 5 sein.</p> </li> <li> <p>Alle Knoten m\u00fcssen \u00fcber Kanten erreichbar sein.</p> </li> <li> <p>Der Graph muss zusammenh\u00e4ngend und zyklusfrei sein.</p> </li> <li> <p>Die Kanten m\u00fcssen ungerichtet sein.</p> </li> <li> <p>Alle Knoten des Eingabe-Graphen m\u00fcssen im Ausgabe-Graphen enthalten sein.</p> </li> </ul> <p></p> <pre><code>// code/output/3 Stromversorgungsplaner.txt\nA B C D E F G H I J K L A 0 B 1 0 C 2 0 0 D 4 0 0 0 E 7 0 0 0 0 F 11 0 0 0 0 0 G 0 17 0 0 0 0 0 H 0 23 0 0 0 0 0 0 I 0 30 0 0 0 0 0 0 0 J 0 38 0 0 0 0 0 0 0 0 K 0 0 48 0 0 0 0 0 0 0 0 L 0 0 58 0 0 0 0 0 0 0 0 0 </code></pre>"},{"location":"Problem3/#geeignete-algorithmen","title":"Geeignete Algorithmen","text":"<p>Es gibt verschiedene Algorithmen, die verwendet werden k\u00f6nnen, um den minimalen Spannbaum eines ungerichteten Graphen zu berechnen. Einige dieser Algorithmen sind:</p> <p>Kruskal-Algorithmus: Dieser Algorithmus sortiert alle Kanten des Graphen nach ihrem Gewicht und f\u00fcgt sie dann eine nach der anderen dem minimalen Spannbaum hinzu, wobei sichergestellt wird, dass keine Schleife entsteht. Der Algorithmus endet, wenn alle Knoten des Graphen Teil des Spannbaums sind.</p> <p>Prim-Algorithmus: Dieser Algorithmus beginnt mit einem beliebigen Knoten des Graphen und f\u00fcgt nacheinander Kanten hinzu, die den aktuellen minimalen Spannbaum mit einem neuen Knoten verbinden. Der Algorithmus endet, wenn alle Knoten des Graphen Teil des Spannbaums sind.</p> <p>Allerdings m\u00fcssen diese Algorithmen modifiziert werden, da die maximale Anzahl an Nachbarn pro Knoten maximal 5 betragen darf.</p>"},{"location":"Problem3/#die-laufzeit-des-algorithmus","title":"Die Laufzeit des Algorithmus","text":"<p>Die Funktion <code>getEdges()</code> hat eine Laufzeit von O(V^2), da sie jedes Element der Adjazenzmatrix durchl\u00e4uft.</p> <p>Die Funktionen <code>getSourceVertexFromEdge()</code> und <code>getTargetVertexFromEdge()</code> haben beide eine Laufzeit von O(V), da sie durch die Liste der Vertices iterieren und den gesuchten Vertex suchen.</p> <p>Die Funktion <code>getAdjacentEdges()</code> hat eine Laufzeit von O(E), da sie durch die Liste der Edges iteriert und jede Kante \u00fcberpr\u00fcft, ob sie den angegebenen Vertex enth\u00e4lt.</p> <p>Die Hauptschleife in <code>kruskal()</code> wird so lange ausgef\u00fchrt, wie es noch Kanten in forest_edges gibt, wodurch sie eine Laufzeit von O(E) hat. </p> <p>Innerhalb dieser Schleife werden in einem For-Loop die Funktionen <code>getSourceVertexFromEdge()</code> und <code>getTargetVertexFromEdge()</code> aufgerufen, die jeweils eine Laufzeit von O(V) haben. </p> <p>In der Hauptschleife wird zus\u00e4tzlich die Funktion <code>getAdjacentEdges()</code> aufgerufen, die eine Laufzeit von O(E) hat und ein weiterer For-Loop mit der Laufzeit O(V).</p> <p>Daraus resultiert eine Laufzeit von O(V^2 + E * ( V^3 + E )).  Dies kann auf O(V^3 * E) vereinfacht werden. </p>"},{"location":"Problem3/#die-implementierung-des-algorithmus","title":"Die Implementierung des Algorithmus","text":"<p>Zur L\u00f6sung dieses Problems wurde der Algorithmus von Kruskal verwendet. Der Algorithmus ist ein Greedy-Algorithmus. Er berechnet den minimalen Spannbaum eines Graphen.</p> <p>Zuerst wird eine Liste aller Kanten des Graphen erstellt. Diese Liste wird nach Gewicht sortiert. Dann wird ein Wald aus B\u00e4umen erstellt, wobei jeder Knoten ein eigener Baum ist. Dann wird die Liste der Kanten durchlaufen. </p> <p>Wenn die Kanten zwei Knoten aus verschiedenen B\u00e4umen verbindet, wird die Kante dem minimalen Spannbaum hinzugef\u00fcgt. Die B\u00e4ume werden dann zusammengef\u00fchrt.</p> <p>Die Funktion gibt eine Adjazenmatrix zur\u00fcck, die aus der Liste der Ausgabe-Kanten erstellt wird.</p> <pre><code>private int[][] kruskal(int[][] matrix, char[] vertexLetters, int max_edges) {\nArrayList&lt;Vertex&gt; vertices = new ArrayList&lt;&gt;();\n// Generiere eine Liste aller Knoten\nfor (int i = 0; i &lt; matrix.length; i++)\nvertices.add(new Vertex(vertexLetters[i], 0));\nArrayList&lt;Edge&gt; edges = getEdges(matrix, vertexLetters); // O(V^2)\n// Sortiere die Kanten nach Gewicht\nedges.sort(Comparator.comparingInt(Edge::getWeight));\n// erstelle einen wald 'forest' (eine menge von b\u00e4umen), wo jeder knoten ein\n// eigener baum ist\nArrayList&lt;ArrayList&lt;Vertex&gt;&gt; forest = new ArrayList&lt;ArrayList&lt;Vertex&gt;&gt;();\nfor (Vertex v : vertices) {\nArrayList&lt;Vertex&gt; tree = new ArrayList&lt;Vertex&gt;();\ntree.add(v);\nforest.add(tree);\n}\n// erstelle eine liste mit den kanten des minimum spanning trees\nArrayList&lt;Edge&gt; forest_edges = new ArrayList&lt;Edge&gt;(edges);\n// erstelle eine liste f\u00fcr die Ausgabe\nArrayList&lt;Edge&gt; output_edges = new ArrayList&lt;Edge&gt;();\n// solange der wald nicht leer ist und der baum noch nicht alle knoten enth\u00e4lt\nwhile (forest_edges.size() &gt; 0) {\n// entferne eine kante (u, v) aus forest\nEdge e = forest_edges.remove(0);\n// finde die b\u00e4ume, die mit der Kante e verbunden sind\nArrayList&lt;Vertex&gt; tree_u = null;\nArrayList&lt;Vertex&gt; tree_v = null;\nfor (ArrayList&lt;Vertex&gt; t : forest) {\nif (t.contains(getSourceVertexFromEdge(e, vertices))) // O(V)\ntree_u = t;\nif (t.contains(getTargetVertexFromEdge(e, vertices))) // O(V)\ntree_v = t;\n}\n// Pr\u00fcfe ob die kante e von einem vertex ausgeht, der bereits mehr als 5 kanten\n// hat\nArrayList&lt;Edge&gt; source_edges = getAdjacentEdges(e.getSource(), output_edges); // O(E)\nArrayList&lt;Edge&gt; target_edges = getAdjacentEdges(e.getTarget(), output_edges); // O(E)\nif (source_edges.size() &gt;= max_edges || target_edges.size() &gt;= max_edges)\ncontinue;\n// wenn u und v in gleichen B\u00e4umen sind -&gt; skip\nif (tree_u == tree_v)\ncontinue;\n// f\u00fcge kante von u und v zur Ausgabe hinzu\noutput_edges.add(e);\n// f\u00fcge baum von v zu baum von u hinzu (merge)\nfor (Vertex v : tree_v)\ntree_u.add(v);\nforest.remove(tree_v);\n}\n// erstelle die Ausgabe-Adjazenzmatrix\nint[][] output_matrix = new int[matrix.length][matrix.length];\nfor (Edge e : output_edges) {\nint source = e.getSource() - 'A';\nint target = e.getTarget() - 'A';\noutput_matrix[source][target] = matrix[source][target];\noutput_matrix[target][source] = matrix[target][source];\n}\nreturn output_matrix;\n}\n</code></pre>"},{"location":"Problem4/","title":"Problem 4 - \"Historische Funde\"","text":"<p>Beim Ausheben der Wege w\u00e4hrend des Stra\u00dfenbaus wurde ein antiker Feuerwerksplan gefunden. Die Lage der pyrotechnischen Effekte und die Z\u00fcndschn\u00fcre sind noch sehr gut zu erkennen.</p> <p>Wie aber ist die Choreographie des Feuerwerks? In welcher Reihenfolge z\u00fcnden die Bomben? K\u00f6nnen Sie den B\u00fcrgern der Graphschaft Schilda helfen? (Unter der Annahme, dass die Z\u00fcndschnur immer mit gleichbleibender Geschwindigkeit abbrennt...)</p>"},{"location":"Problem4/#modellierung-des-problems","title":"Modellierung des Problems","text":"<p>Das Problem l\u00e4sst sich als Graphenmodell mit ungerichteten Kanten darstellen. Das Steichholz und die Feuerwerksk\u00f6rper sind die Knoten, die Z\u00fcndschn\u00fcre sind die Kanten. Die Kosten der Kanten sind die L\u00e4nge der Z\u00fcndschn\u00fcre.</p> <p>Es wird die korrekte Reihenfolge gesucht, in der die Feuerwerksk\u00f6rper gez\u00fcndet werden wenn das Streichholz den ersten Feuerwerksk\u00f6rper z\u00fcndet.</p> <p>Um den Graph zu modellieren werden die Java-Bibliotheken <code>JGraphT</code> und <code>JGraphX</code> verwendet. Mit <code>JGraphT</code> wird der Graph als Datenstruktur modelliert. Mit <code>JGraphX</code> wird der Graph als Grafik dargestellt und auf dem Bildschirm dargestellt.</p>"},{"location":"Problem4/#die-eingabe","title":"Die Eingabe","text":"<p>Um das Bild der Aufgabenstellung in konkrete Daten zu \u00fcbersetzen, wurden hier Sch\u00e4tzungen der L\u00e4nge der Z\u00fcndschn\u00fcre vorgenommen und in einer Grafik dargestellt. Die Knoten wurden mit Buchstaben von A - I beschriftet.</p> <p>Die Eingabe besteht aus einem Graphen, der aus Kanten und Knoten besteht. Diese werden aus einer <code>.txt</code> Datei gelesen und in eine Instanz der Klasse <code>AdjazenzMatrix.java</code> geladen. Diese Instanz dient als Basis f\u00fcr die Berechnung des minimalen Spannbaums.</p> <p></p> <pre><code>// code/data/problem4.txt\nA B C D E F G H I\nA 0\nB 1 0\nC 0 4 0\nD 0 1 2 0\nE 0 0 0 0 0\nF 0 4 0 3 3 0\nG 0 0 0 0 1 0 0\nH 0 0 0 0 3 0 4 0\nI 0 0 0 0 0 2 3 0 0\n</code></pre>"},{"location":"Problem4/#die-ausgabe","title":"Die Ausgabe","text":"<p>Die Ausgabe wird als Graph in einem Fenster dargestellt und in die Datei <code>4 Feuerwerksplaner.txt</code> geschrieben. Das Fenster besteht aus drei Teilen. Auf der linken Seite wird der Eingabegraph dargestellt. In der Mitte wird der berechnete Graph dargestellt mit dem k\u00fcrzesten Weg von A zu jedem anderen Knoten. Die Gewichte der Kanten zu den jeweiligen Knoten stellen die minimalen Gesamtkosten zum jeweiligen Knoten. Im rechten Teil wird eine Liste der Knoten dargestellt, in der die Knoten in der Reihenfolge aufgelistet sind, in der sie gez\u00fcndet werden.</p> <p>Ein korrekte Ausgabe erf\u00fcllt folgende Eigenschaften:</p> <ul> <li> <p>Die Kantengewichte m\u00fcssen die minimalen Gesamtkosten zum jeweiligen Knoten sein.</p> </li> <li> <p>Alle Knoten m\u00fcssen \u00fcber Kanten erreichbar sein.</p> </li> <li> <p>Der Graph muss zusammenh\u00e4ngend und zyklusfrei sein.</p> </li> <li> <p>Die Kanten m\u00fcssen ungerichtet sein.</p> </li> <li> <p>Alle Knoten des Eingabe-Graphen m\u00fcssen im Ausgabe-Graphen enthalten sein.</p> </li> </ul> <p></p> <pre><code>// code/output/4 Feuerwerksplaner.txt\nA B C D E F G H I A 0 B 1 0 C 0 0 0 D 0 2 4 0 E 0 0 0 0 0 F 0 5 0 0 8 0 G 0 0 0 0 9 0 0 H 0 0 0 0 11 0 0 0 I 0 0 0 0 0 7 0 0 0 </code></pre>"},{"location":"Problem4/#geeignete-algorithmen","title":"Geeignete Algorithmen","text":"<p>F\u00fcr dieses Problem eignen sich die Algorithmen Dijkstra, Bellman-Ford und A*. </p> <p>Der Bellman-Ford-Algorithmus ist ein dynamischer Algorithmus, der iterativ die Entfernungen von dem Startknoten zu allen anderen Knoten im Graphen aktualisiert, bis sie stabil geworden sind. Der Dijkstra-Algorithmus hingegen ist ein statischer Algorithmus, der alle Entfernungen auf einmal berechnet.</p> <p>Der A Algorithmus ist ein Best-First-Suchalgorithmus, der dazu verwendet wird, den k\u00fcrzesten Pfad von einem Startknoten zu einem Zielknoten in einem Graphen zu finden. Der A-Algorithmus verwendet dabei eine Heuristik, um zu entscheiden, welche Knoten als n\u00e4chstes untersucht werden sollen. Diese Heuristik basiert auf einer Sch\u00e4tzung der Entfernung des Knotens vom Ziel und wird verwendet, um den Algorithmus dazu zu bringen, sich auf die Knoten zu konzentrieren, die wahrscheinlich zum Ziel f\u00fchren.</p>"},{"location":"Problem4/#die-laufzeit-des-algorithmus","title":"Die Laufzeit des Algorithmus","text":"<p>Die Laufzeit der Funktion <code>dijkstra()</code> h\u00e4ngt von der Anzahl der Knoten (V) und der Anzahl der Kanten (E) im Graph ab. </p> <p>Die Funktion <code>getEdges(matrix, vertexLetters)</code> hat eine Laufzeit von O(V^2), da sie eine Schleife \u00fcber alle V^2 m\u00f6glichen Kanten des Graphs durchf\u00fchrt. </p> <p>Die Funktion <code>getNeighbors(u, vertices, edges)</code> hat eine Laufzeit von O(V * E), da sie eine Schleife \u00fcber alle V Vertices und eine Schleife \u00fcber alle E Kanten durchf\u00fchrt, um alle Nachbarn von u zu finden.</p> <p>Die Funktion <code>getWeightSum(u, v, edges)</code> hat eine Laufzeit von O(E), da sie eine Schleife \u00fcber alle E Kanten durchf\u00fchrt, um die Gewichte zu addieren.</p> <p>Die while-Schleife hat eine Laufzeit von O(V), da alle Knoten in der Priorit\u00e4tswarteschlange einmal durchlaufen werden k\u00f6nnen. Innerhalb der while-Schleife wird ein Element aus der Warteschlange genommen O(log(V)) und die Funktion <code>getNeighbors()</code> aufgerufen. F\u00fcr jeden Nachbarn wird die Funktion <code>getWeightSum()</code> aufgerufen.</p> <p>Daraus resultiert eine Laufzeit von O(V^2) + O(V) * ( O(log(V) + ( O(V * E) * O(E) ) ). Umgeformt ergibt sich eine Laufzeit von O(V^2 + V * log(V) + V^3 * E).</p> <p>Dies kann auf O(V^3 * E) vereinfacht werden.</p>"},{"location":"Problem4/#die-implementierung-des-algorithmus","title":"Die Implementierung des Algorithmus","text":"<p>Zur L\u00f6sung des Problems wurde der Dijkstra-Algorithmus verwendet.  Der Dijkstra-Algorithmus ist ein Greedy-Algorithmus. </p> <p>Der Algorithmus verwendet dabei eine Priorit\u00e4tswarteschlange, um die Knoten zu sortieren, die als n\u00e4chstes untersucht werden sollen. Die Priorit\u00e4tswarteschlange wird mit den Knoten initialisiert, die direkt mit dem Startknoten verbunden sind. Die Knoten werden dann in der Priorit\u00e4tswarteschlange nach ihrer Entfernung vom Startknoten sortiert. Der Algorithmus w\u00e4hlt dann den Knoten mit der geringsten Entfernung aus der Priorit\u00e4tswarteschlange aus und aktualisiert die Entfernungen aller Knoten, die mit diesem Knoten verbunden sind. </p> <p>Dadurch bekommt jeder Knoten einen Wert, der die Entfernung vom Startknoten angibt. Der Algorithmus wird dann wiederholt, bis alle Knoten in der Priorit\u00e4tswarteschlange untersucht wurden.</p> <pre><code>private int[][] dijkstra(int[][] matrix, char[] vertexLetters) {\n// Generiere eine Liste aller Knoten\nfor (int i = 0; i &lt; matrix.length; i++)\nvertices.add(new Vertex(vertexLetters[i], 0));\nArrayList&lt;Edge&gt; edges = getEdges(matrix, vertexLetters); // O(V^2)\n// Initialisiere die Distanz im Startknoten mit 0 und in allen anderen Knoten\n// mit \u221e.\nfor (Vertex vertex : vertices) {\nvertex.setKey(Integer.MAX_VALUE);\nvertex.setPredecessor(null);\n}\nvertices.get(0).setKey(0);\n// Speichere alle Knoten in einer Priorit\u00e4tswarteschlange queue\nPriorityQueue&lt;Vertex&gt; queue = new PriorityQueue&lt;Vertex&gt;(\nComparator.comparingInt(Vertex::getKey));\nqueue.addAll(vertices);\n// Solange es noch unbesuchte Knoten gibt, w\u00e4hle darunter denjenigen mit\n// minimaler Distanz aus und\nwhile (!queue.isEmpty()) {\n// Nehme den Knoten mit dem kleinsten Wert aus der Warteschlange\nVertex v = queue.poll();\n// 1. speichere, dass dieser Knoten schon besucht wurde\nv.setVisited(true);\n// 2. berechne f\u00fcr alle noch unbesuchten Nachbarknoten die Summe des jeweiligen\n// Kantengewichtes und der Distanz im aktuellen Knoten\nfor (Vertex n : getNeighbors(v, vertices, edges)) {\n// 3. ist dieser Wert f\u00fcr einen Knoten kleiner als die\n// dort gespeicherte Distanz, aktualisiere sie und setze den aktuellen Knoten\n// als Vorg\u00e4nger. (Dieser Schritt wird auch als Update bezeichnet. )\nint sum = v.getKey() + getWeightSum(v, n, edges);\nif (sum &gt;= n.getKey())\ncontinue;\nn.setKey((int) sum);\nn.setPredecessor(v);\n// Aktualisiere die Priorit\u00e4tswarteschlange\nqueue.remove(n);\nqueue.add(n);\n}\n}\n// Sortiere Knoten nach Distanz\nvertices.sort(Comparator.comparingInt(Vertex::getKey));\n// Erstelle eine neue Adjazenzmatrix, die den jeweils k\u00fcrzesten Weg zu jedem\n// Knoten enth\u00e4lt\nint[][] matrix_output = new int[matrix.length][matrix.length];\nfor (Vertex vertex : vertices) {\nif (vertex.getPredecessor() == null)\ncontinue;\nmatrix_output[vertex.getPredecessor().getLetter() - 'A'][vertex.getLetter() - 'A'] = vertex.getKey();\nmatrix_output[vertex.getLetter() - 'A'][vertex.getPredecessor().getLetter() - 'A'] = vertex.getKey();\n}\nreturn matrix_output;\n}\n</code></pre>"},{"location":"Problem5/","title":"Problem 5 - \"Die Festhochzeit - das Verteilen der Einladungen\"","text":"<p>Zum gro\u00dfen Hochzeitfest in Schilda sollen nat\u00fcrlich alle Ortsbewohner eingeladen werden.</p> <p>Da in der letzten Zeit in Schilda viele neue Stra\u00dfen gebaut worden waren, muss der Brieftr\u00e4ger eine neue Route finden. Gl\u00fccklicherweise haben alle H\u00e4user ihre Briefk\u00e4sten an die neuen Stra\u00dfen gestellt, so dass der Brieftr\u00e4ger nur noch den k\u00fcrzesten Weg finden muss, der ausgehend von der Post durch alle Stra\u00dfen und dann wieder zur\u00fcck zur Post f\u00fchrt.</p> <p>Hier sind Sie wieder gefragt: Unterst\u00fctzen Sie den Brieftr\u00e4ger und entwerfen Sie die neue Route f\u00fcr den Brieftr\u00e4ger. Den Stadtplan kennen Sie ja bereits, schlie\u00dflich haben Sie die Stra\u00dfen gebaut.</p>"},{"location":"Problem5/#modellierung-des-problems","title":"Modellierung des Problems","text":"<p>Das Problem l\u00e4sst sich Graphenmodell mit ungerichteten und ungewichteten Kanten darstellen. F\u00fcr die Eingabe wurde ein eigener Graph erstellt, die Kreise symbolisieren die Knoten und die Verbindungen dazwischen die Kanten. (Der Graph muss ein Eulerkreis sein, das bedeutet er darf nur Knoten mit gerader Kantenanzahl besitzen. =&gt; nochmal nachlesen)</p> <p>Es wird nach einem Weg auf dem Graphen gesucht, der jede Kante nur einmal abl\u00e4uft und bei dem der Startknoten gleich dem Endknoten ist.</p> <p>Um den Ausgabegraph zu modellieren, wird an einem beliebigen Startknoten angefangen und von diesem aus alle Knoten abgelaufen bis ein bereits bekannter Knoten wieder getroffen wird, der keine freien Nachbarn mehr besitzt. Wenn es noch freie Knoten gibt, geht man den Weg wieder zur\u00fcck, bis man einen Knoten erreicht der noch freie Nachbarn besitzt. Dieser Vorgang wird wiederholt, bis es keinen Knoten mit unbesuchten Nachbarn mehr gibt.</p> <p>Um den Graph zu modellieren werden die Java-Bibliotheken <code>JGraphT</code> und <code>JGraphX</code> verwendet. Mit <code>JGraphT</code> wird der Graph als Datenstruktur modelliert. Mit <code>JGraphX</code> wird der Graph als Grafik dargestellt und auf dem Bildschirm dargestellt.</p>"},{"location":"Problem5/#die-eingabe","title":"Die Eingabe","text":"<p>Die Eingabe besteht aus einem Graphen, der aus Kanten und Knoten besteht. Diese werden aus einer <code>.txt</code> Datei gelesen und in eine Instanz der Klasse <code>AdjazenzMatrix.java</code> geladen. Diese Instanz dient als Basis f\u00fcr die Berechnung einer geschlossenen Eulertour.</p> <p>Das Bild wurde passend zur Aufgabenstellung selbst gezeichnet und mit den Buchstaben von A bis I beschriftet und daraus wurde die Datei <code>problem5.txt</code> erstellt.</p> <p></p> <pre><code>// code/data/problem5.txt\nA B C D E F G H I\nA 0\nB 1 0\nC 0 1 0\nD 0 0 1 0\nE 1 0 0 1 0\nF 1 0 0 0 0 0\nG 1 0 0 0 0 1 0\nH 0 1 1 0 0 0 0 0\nI 0 1 1 0 0 0 0 0 0\n</code></pre>"},{"location":"Problem5/#die-ausgabe","title":"Die Ausgabe","text":"<p>Die Ausgabe wird (als Graph) Reihenfolge von Knoten in einem Fenster dargestellt und in die Datei <code>5 Festhochzeitsplaner</code> geschrieben. Das Fenster besteht aus zwei H\u00e4lften. Auf der linken Seite wird der Eingabegraph dargestellt. Auf der rechten Seite wird der berechnete (Graph) Weg dargestellt.</p> <p>Eine korrekte Ausgabe erf\u00fcllt folgende Eigenschaften:</p> <ul> <li> <p>Alle Kanten m\u00fcssen genau einmal enthalten sein</p> </li> <li> <p>Der Endknoten muss gleich dem Startknoten sein</p> </li> <li> <p>Der Graph muss zusammenh\u00e4ngend sein</p> </li> <li> <p>Bei der Ausgabe Reihenfolge m\u00fcssen die folgenden Knoten immer Nachbarknoten des vorherigen sein</p> </li> <li> <p>Alle Knoten des Eingabe-Graphen m\u00fcssen im Ausgabe-Graphen enthalten sein.</p> </li> </ul> <p></p> <pre><code>// code/output/5 Festhochzeitsplaner.txt\n[A, B, C, H, B, I, C, D, E, A, F, G, A]\n</code></pre>"},{"location":"Problem5/#geeignete-algorithmen","title":"Geeignete Algorithmen","text":"<p>Es gibt verschiedene Algorithmen, die verwendet werden k\u00f6nnen, um eine geschlossenen Eulertour eines ungerichteten und ungewichteten Graphen zu berechnen. Einige dieser Algorithmen sind:</p>"},{"location":"Problem5/#algorithmus-von-hierholzer","title":"Algorithmus von Hierholzer","text":"<p>Dieser Algorithmus basiert auf der Tatsache, dass in einem ungerichteten und ungewichteten Graphen, mit Knoten, die alle eine gerade Kantenanzahl besitzen eine geschlossene Eulertour existiert. Der Algorithmus startet an einem beliebigen Knoten und folgt dann den Kanten, bis er wieder zum Ausgangsknoten zur\u00fcckkehrt. Wenn es am aktuellen Knoten keine freien Kanten gibt, geht der Algorithmus wieder zu einem Knoten mit freien Kanten zur\u00fcck. Der Algorithmus endet, wenn alle Kanten besucht wurden und man wieder am Ausgangsknoten angekommen ist.</p>"},{"location":"Problem5/#algorithmus-von-fleury","title":"Algorithmus von Fleury","text":"<p>Dieser Algorithmus basiert ebenfalls auf der Tatsache, dass in einem ungerichteten und ungewichteten Graphen, mit Knoten, die alle eine gerade Kantenanzahl besitzen eine geschlossene Eulertour existiert. Der Algorithmus startet ebenfalls an einem beliebigen Knoten, der keine Br\u00fcckenkanten besitzt und f\u00fcgt dann immer eine weitere Kante hinzu, die den aktuellen Knoten mit einem anderen Knoten verbindet. Wenn es mehrere m\u00f6gliche freie Kanten gibt, wird zuerst die Kante gew\u00e4hlt, die keine Br\u00fcckenkante ist. Wenn es am aktuellen Knoten keine freien Kanten gibt, geht der Algorithmus wieder zu einem Knoten mit freien Kanten zur\u00fcck. Dieser Prozess wird wiederholt, bis alle Kanten besucht wurden.</p>"},{"location":"Problem5/#die-laufzeit-des-algorithmus","title":"Die Laufzeit des Algorithmus","text":"<p>Laufzeit Problem 5 = O(V^2)</p> <p>Die Funktion <code>mirrorMatrix()</code> hat eine Laufzeit von O(V^2), da zwei for-Schleifen verschachtelt sind, die jeweils eine Laufzeit von O(V) beistzen.</p> <p>Die Funktion <code>isEulerGraph</code> hat eine Laufzeit von O(V^2), da zwei for-Schleifen verschachtelt sind, die jeweils eine Laufzeit von O(V) beistzen.</p> <p>Die Laufzeit der Funktion <code>hierholzerEulerTour()</code> h\u00e4ngt von der Anzahl der Knoten (V) im Graph ab. Die Laufzeit der Schleife, die die Nachbarn eines Knotens durchl\u00e4uft, betr\u00e4gt O(V^2), da jeder Knoten mit jedem anderen Knoten verglichen werden Kann. Die Laufzeit des Stacks betr\u00e4gt normal O(1). Daraus ergibt sich eine Laufzeit von O(V^2)</p> <p>Die while-Schleife hat eine Laufzeit von O(V), da alle Knoten in der Priorit\u00e4tswarteschlange einmal durchlaufen werden k\u00f6nnen. Innerhalb der while-Schleife wird ein Element aus der Warteschlange genommen O(log(V)) und die Funktion <code>getNeighbors()</code> aufgerufen.</p> <p>Daraus resultiert eine Laufzeit von O(V^2) + O(V^2) + O(V^2). Umgeformt ergibt sich eine Laufzeit von 3 * O(V^2).</p>"},{"location":"Problem5/#die-implementierung-des-algorithmus","title":"Die Implementierung des Algorithmus","text":"<p>Zur L\u00f6sung des Problems wurde der Algorithmus von Hierholzer implementiert. Der Algorithmus von Hierholzer basiert darauf, dass sich ein eulerscher Graph in paarweise kantendisjunkte Kreise zerlegen l\u00e4sst. Als Datenstruktur wurde ein Stack verwendet, der Instanzen der Klasse Character beinhaltet, die den Knoten des Graphen entsprechen, sowie eine ArrayList zum Speichern der Eulertour:</p> <p>Zuerst wir die Matrix des Graphen der Funktion <code>mirrorMatrix</code> gespiegelt, damit die Kanten in beide Richtungen verf\u00fcgbar sind.</p> <p>Im n\u00e4chsten Schritt wird mit der Funktion <code>isEulerGraph</code> \u00fcberpr\u00fcft, ob der Graph ein Eulergraph ist.</p> <p>Wenn dies der Fall ist, wird die Funktion <code>hierholzerEulerTour()</code> aufgerufen, die die Eulertour berechnet. Die Funktion nimmt die Matrix des Graphen und ein Array mit den Buchstaben der Knoten entgegen. Der erste Knoten wird als Startpunkt gew\u00e4hlt und auf den Stack gelegt. Solange der Stack nicht leer ist, wird der oberste Knoten des Stacks betrachtet. Der Algorithmus durchl\u00e4uft dann alle Nachbarn des aktuellen Knotens und pr\u00fcft, ob eine Kante zwischen ihnen besteht. Falls ja, wird der Nachbar auf den Stack gelegt und die Kante entfernt. Falls kein weiterer Nachbar gefunden wurde, wird der aktuelle Knoten vom Stack entfernt und dem Pfad hinzugef\u00fcgt. Am Ende wird der Pfad zur\u00fcckgegeben.</p> <pre><code>  // Wenn alle Knotengrade gerade sind, dann ist der Graph ein Eulergraph\nprivate boolean isEulerGraph(int[][] matrix) {\nfor (int i = 0; i &lt; matrix.length; i++) {\nint degree = 0;\nfor (int j = 0; j &lt; matrix.length; j++) {\nif (matrix[i][j] == 1)\ndegree++;\n}\nif (degree % 2 != 0)\nreturn false;\n}\nreturn true;\n}\nprivate ArrayList&lt;Character&gt; hierholzerEulerTour(int[][] matrix, char[] vertexLetters) {\n// ArrayList, um den Pfad zu speichern\nArrayList&lt;Character&gt; path = new ArrayList&lt;&gt;();\n// Stack, um die n\u00e4chsten Knoten zu speichern\nStack&lt;Character&gt; stack = new Stack&lt;&gt;();\n// Erster Knoten als Startpunkt\nchar start = vertexLetters[0];\nstack.push(start);\n// Solange der Stack nicht leer ist\nwhile (!stack.isEmpty()) {\n// Hole aktuellen Knoten aus dem stack\nchar current = stack.peek();\n// Gehe alle Nachbarn durch\nboolean foundNext = false;\nfor (int i = 0; i &lt; matrix.length; i++) {\n// Index des aktuellen Knotens\nint index = current - vertexLetters[0];\n// Wenn der Knoten keinen Nachbarn hat, \u00fcberspringe ihn\nif (matrix[index][i] != 1)\ncontinue;\n// f\u00fcge den Nachbarn dem Pfad/Stack hinzu\nstack.push(vertexLetters[i]);\n// Entferne die Kante zwischen dem aktuellen und n\u00e4chsten Knoten\nmatrix[index][i] = 0;\nmatrix[i][index] = 0;\nfoundNext = true;\nbreak;\n}\n// Wenn kein weiterer Nachbar gefunden wurde, entferne den aktuellen Knoten vom\n// Stack und f\u00fcge ihn dem Pfad hinzu\nif (!foundNext)\npath.add(0, stack.pop());\n}\nreturn path;\n}\nprivate int[][] mirrorMatrix(int[][] matrix) {\nint[][] mirrored = new int[matrix.length][matrix.length];\nfor (int i = 0; i &lt; matrix.length; i++)\nfor (int j = 0; j &lt; matrix.length; j++)\nif (i &lt; j)\nmirrored[i][j] = matrix[j][i];\nelse\nmirrored[i][j] = matrix[i][j];\nreturn mirrored;\n}\n</code></pre>"},{"location":"Problem6/","title":"Problem 6 - \"Wohin nur mit den G\u00e4sten?\"","text":"<p>Zum Einweihungsfest werden zahlreiche ausw\u00e4rtige G\u00e4ste eingeladen. Reisen diese allerdings alle mit dem Auto an, dann ist ohne hervorragende Verkehrsplanung ein Stau in der Innenstadt vorprogrammiert. Parken k\u00f6nnen die Autos auf dem Parkplatz des neuen Supermarktes. </p> <p>Doch wie soll der Verkehr durch die Stadt geleitet werden, dass m\u00f6glichst viele Fahrzeuge von der Autobahn zum Parkplatz gelangen k\u00f6nnen, ohne dass sich lange Schlangen vor den Ampeln bilden? Die Kapazit\u00e4t der einzelnen Stra\u00dfen haben Ihnen die B\u00fcrger der Stadt bereits aufgezeichnet. </p> <p>Sie sollen nun planen, wie viele Wagen \u00fcber die einzelnen Wege geleitet werden sollen.</p>"},{"location":"Problem6/#modellierung-des-problems","title":"Modellierung des Problems","text":"<p>Das Problem l\u00e4sst sich als Graphenmodell mit gerichteten Kanten darstellen. Die Autobahn, die Ampeln und der Parkplatz sind die Knoten, die Stra\u00dfen sind die Kanten. Die Kosten der Kanten sind die Kapazit\u00e4t f\u00fcr Fahrzeuge der Stra\u00dfen.</p> <p>Es wird die jeweilige Anzahl an Fahrzeugen gesucht, die \u00fcber die einzelnen Kanten gef\u00fchrt werden sollen, damit die Fahrzeuge ohne Stau zum Parkplatz gelangen.</p> <p>Um den Graph zu modellieren werden die Java-Bibliotheken <code>JGraphT</code> und <code>JGraphX</code> verwendet. Mit <code>JGraphT</code> wird der Graph als Datenstruktur modelliert. Mit <code>JGraphX</code> wird der Graph als Grafik dargestellt und auf dem Bildschirm dargestellt.</p>"},{"location":"Problem6/#die-eingabe","title":"Die Eingabe","text":"<p>Das Bild der Aufgabenstellung wurde mit Buchstaben von A - F beschriftet und dienen als Bezeichnung f\u00fcr die Knoten. Die Werte der Kanten werden auch aus der Grafik \u00fcbernommen.</p> <p>Die Eingabe besteht aus einem Graphen, der aus Kanten und Knoten besteht. Diese werden aus einer <code>.txt</code> Datei gelesen und in eine Instanz der Klasse <code>AdjazenzMatrix.java</code> geladen. Diese Instanz dient als Basis f\u00fcr die Berechnung des minimalen Spannbaums.</p> <p></p> <pre><code>// code/data/problem6.txt\nA B C D E F A 0 14 16 0 0 0\nB 0 0 0 15 0 0\nC 0 6 0 0 15 0\nD 0 0 4 0 7 10\nE 0 0 0 0 0 17\nF 0 0 0 0 0 0\n</code></pre>"},{"location":"Problem6/#die-ausgabe","title":"Die Ausgabe","text":"<p>Die Ausgabe wird als Graph in einem Fenster dargestellt und in die Datei <code>6 Verkehrsplaner.txt</code> geschrieben. Das Fenster besteht zwei H\u00e4lften. Auf der linken Seite wird der Eingabegraph dargestellt. Auf der rechten Seite wird der Ausgabegraph dargestellt. In diesem Graphen entsprechen die Werte der Kanten die Anzahl der Autos, die \u00fcber die jeweilige Stra\u00dfe gef\u00fchrt werden sollen.</p> <p>Vor der Ausgabe werden die inversen/negativen Kanten entfernt. Diese werden nicht ben\u00f6tigt, da sie keine Rolle spielen. </p> <p>Ein korrekte Ausgabe erf\u00fcllt folgende Eigenschaften:</p> <ul> <li> <p>Alle Knoten m\u00fcssen von dem ersten Knoten A erreichbar sein.</p> </li> <li> <p>Der Fluss der Kanten muss positiv und ganzzahlig sein.</p> </li> <li> <p>Der Fluss der Kanten darf nicht gr\u00f6\u00dfer als deren Kapazit\u00e4t sein.</p> </li> <li> <p>Der maximale Fluss muss gleich der Summe der Kapazit\u00e4ten der Kanten sein, die von A ausgehen und in dem letzten Knoten enden.</p> </li> <li> <p>Der maximale Fluss muss maximal sein, also es darf keine andere Flussverteilung geben, die einen h\u00f6heren Fluss ergibt.</p> </li> <li> <p>Der Graph muss zusammenh\u00e4ngend und zyklusfrei sein.</p> </li> <li> <p>Die Kanten m\u00fcssen gerichtet sein.</p> </li> <li> <p>Alle Knoten des Eingabe-Graphen m\u00fcssen im Ausgabe-Graphen enthalten sein.</p> </li> </ul> <p></p> <pre><code>// code/output/6 Verkehrsplaner.txt\nA B C D E F A 0 12 15 0 0 0 B 0 0 0 12 0 0 C 0 0 0 0 15 0 D 0 0 0 0 2 10 E 0 0 0 0 0 17 F 0 0 0 0 0 0 </code></pre>"},{"location":"Problem6/#geeignete-algorithmen","title":"Geeignete Algorithmen","text":"<p>Es gibt verschiedene Algorithmen, die verwendet werden k\u00f6nnen, um den maximalen Fluss in einem gerichteten Graph zu berechnen. Einige dieser Algorithmen sind:</p> <p>Ford-Fulkerson-Algorithmus: Dieser Algorithmus ist ein iterativer Algorithmus, der in jedem Schritt den Fluss durch einen Pfad erh\u00f6ht, der vom Quellknoten zum Zielknoten f\u00fchrt und dessen Kapazit\u00e4t noch nicht vollst\u00e4ndig ausgesch\u00f6pft ist. Der Algorithmus endet, wenn kein solcher Pfad mehr existiert.</p> <p>Dinic-Algorithmus: Dieser Algorithmus ist ebenfalls ein iterativer Algorithmus, der den Fluss durch den Graph in jedem Schritt erh\u00f6ht, indem er einen Pfad vom Quellknoten zum Zielknoten sucht, dessen Kapazit\u00e4t noch nicht vollst\u00e4ndig ausgesch\u00f6pft ist. Im Gegensatz zum Ford-Fulkerson-Algorithmus verwendet der Dinic-Algorithmus jedoch eine Heuristik, um schneller zum Ergebnis zu gelangen.</p> <p>Edmonds-Karp-Algorithmus: Dieser Algorithmus ist eine Variation des Ford-Fulkerson-Algorithmus und verwendet auch eine Heuristik, um schneller zum Ergebnis zu gelangen. Im Gegensatz zum Dinic-Algorithmus verwendet der Edmonds-Karp-Algorithmus jedoch eine Breitensuche statt einer Tiefensuche, um Pfade im Graph zu finden.</p> <p>Preflow-Push-Algorithmus: Dieser Algorithmus ist ein schneller, parallelisierbarer Algorithmus, der den Fluss durch den Graph in jedem Schritt erh\u00f6ht, indem er einen Pfad vom Quellknoten zum Zielknoten sucht, dessen Kapazit\u00e4t noch nicht vollst\u00e4ndig ausgesch\u00f6pft ist. Im Gegensatz zu den anderen Algorithmen, die hier aufgef\u00fchrt sind, ist der Preflow-Push-Algorithmus jedoch nicht iterativ, sondern arbeitet in einem einzelnen Durchgang.</p>"},{"location":"Problem6/#die-laufzeit-des-algorithmus","title":"Die Laufzeit des Algorithmus","text":"<p>Die Laufzeit der Funktion <code>bfs()</code> ist O(V + E). In jedem Schritt wird ein Knoten aus der Warteschlange entfernt und die Nachbarknoten des Knotens werden in die Warteschlange aufgenommen. Da jeder Knoten nur einmal in die Warteschlange aufgenommen wird und jede Kante nur einmal betrachtet wird, betr\u00e4gt die Laufzeit O(V + E).</p> <p>Die Laufzeit des Ford-Fulkerson-Algorithmus ist O(V * E^2). Der Algorithmus wird in jedem Schritt iterativ ausgef\u00fchrt, bis kein Pfad mehr vom Quellknoten zum Zielknoten verf\u00fcgbar ist, der dessen Kapazit\u00e4t noch nicht vollst\u00e4ndig ausgesch\u00f6pft hat. In jedem Schritt wird eine Breitensuche ausgef\u00fchrt, um einen solchen Pfad zu finden. </p> <p>Da am Ende der <code>fordFulkerson(int[][] matrix)</code> Funktion noch eine Ausgabematrix erzeugt wird erh\u00f6ht sich die Laufzeit um O(V^2). Mit der gleichen Laufzeit werden zus\u00e4tzlich noch die inversen Kanten des Graphen entfernt.</p> <pre><code>// Filtere die inversen Kanten\nfor (int i = 0; i &lt; matrix_output.length; i++)\nfor (int j = 0; j &lt; matrix_output[i].length; j++)\nif (matrix_output[i][j] &lt; 0)\nmatrix_output[i][j] = 0;\n</code></pre> <p>Daraus folgt eine Laufzeit von O(V * E^2 + V^2).</p>"},{"location":"Problem6/#die-implementierung-des-algorithmus","title":"Die Implementierung des Algorithmus","text":"<p>Zur L\u00f6sung des Problems wurde der Ford-Fulkerson-Algorithmus verwendet. Genauer gesagt wurde der Edmonds-Karp-Algorithmus verwendet, da dieser eine Breitensuche verwendet, um Pfade im Graph zu finden.  </p> <p>Zuerst wird die Matrix <code>matrix</code> in eine echte Kopie <code>output</code> kopiert. Die echte Kopie wird sp\u00e4ter als Ausgabe verwendet.</p> <p>Danach wird ein Eltern-Array <code>parent</code> erstellt, das die Elternknoten der Knoten im Graph speichert. Dieses Array wird sp\u00e4ter verwendet, um den Pfad vom Quellknoten zum Zielknoten zu finden.</p> <p>Als n\u00e4chstes wird eine Breitensuche ausgef\u00fchrt, um einen Pfad vom Quellknoten zum Zielknoten zu finden, dessen Kapazit\u00e4t noch nicht vollst\u00e4ndig ausgesch\u00f6pft ist. Die Breitensuche wird durch die Funktion <code>bfs()</code> ausgef\u00fchrt. Die Funktion <code>bfs()</code> gibt <code>true</code> zur\u00fcck, wenn ein Pfad gefunden wurde, der vom Quellknoten zum Zielknoten f\u00fchrt und dessen Kapazit\u00e4t noch nicht vollst\u00e4ndig ausgesch\u00f6pft ist. Andernfalls wird <code>false</code> zur\u00fcckgegeben.</p> <p>Als Datenstruktur der <code>bfs()</code> Funktion wird eine LinkedList verwendet. Die Laufzeit der <code>poll()</code> Funktion betr\u00e4gt O(1), da die LinkedList eine doppelt verkettete Liste ist. Die Laufzeit der <code>add()</code> Funktion betr\u00e4gt ebenfalls O(1), da die LinkedList eine doppelt verkettete Liste ist.</p> <p>Wenn ein solcher Pfad gefunden wurde, wird der minimale Fluss des Pfades berechnet. Der minimale Fluss des Pfades ist die kleinste Kapazit\u00e4t, die noch nicht vollst\u00e4ndig ausgesch\u00f6pft ist. Dieser Wert wird dann zum maximalen Fluss des Graphen addiert. </p> <p>Zuletzt wird eine neue Ausgabematrix erstellt, die nur aus dem positiven Fluss des Graphen besteht. </p> <pre><code>/**\n * Laufzeit: O(V * E^2 + V^2)\n * \n * @param matrix\n * @return\n */\nprivate int[][] fordFulkerson(int[][] matrix) {\n// Anzahl der Knoten im Graph\nint nodes = matrix[0].length;\n// Die Quelle is der erste Knoten\nint source = 0;\n// Die Senke ist der letzte Knoten\nint sink = nodes - 1;\n// Flow ist zu Beginn 0\nmax_flow = 0;\nint u, v;\n// Erzeuge echte Kopie der Matrix f\u00fcr Output\nint output[][] = new int[nodes][nodes];\nfor (u = 0; u &lt; nodes; u++)\nfor (v = 0; v &lt; nodes; v++)\noutput[u][v] = matrix[u][v];\n// Erzeuge ein Eltern Array zum speichern der m\u00f6glichen BFS-Pfade\nint parent[] = new int[nodes];\n// Wenn f\u00fcr einen Pfad der BFS m\u00f6glich ist, \u00fcberpr\u00fcfe seinen maximalen Fluss\nwhile (bfs(matrix, output, source, sink, parent)) {\n// Setze den Pfad Fluss auf unendlich\nint path_flow = Integer.MAX_VALUE;\n// Finde den maximalen Fluss durch die m\u00f6glichen Pfade\nfor (u = sink; u != source; u = parent[u]) {\nv = parent[u];\npath_flow = Math.min(path_flow, output[v][u]);\n}\n// aktualisiere die Kanten aus dem Eltern Array\nfor (u = sink; u != source; u = parent[u]) {\nv = parent[u];\n// Ziehe den Fluss-Pfad den Kanten ab\noutput[v][u] -= path_flow;\n// Addiere den Fluss-Pfad auf die Inversen Kanten\noutput[u][v] += path_flow;\n}\n// Addiere die einzelnen Flusspfade auf den maximalen Fluss\nmax_flow += path_flow;\n}\n// Ziehe von der Eingabe Matrix die \u00fcbrigen Flussgewichte ab\nint[][] outputGraph = new int[nodes][nodes];\nfor (int i = 0; i &lt; matrix[0].length; i++)\nfor (int j = 0; j &lt; matrix[0].length; j++)\noutputGraph[i][j] = matrix[i][j] - output[i][j];\nreturn outputGraph;\n}\n/**\n * Laufzeit: O(V + E)\n * \n * @param matrix\n * @param output\n * @param s\n * @param t\n * @param parent\n * @return\n */\nprivate boolean bfs(int[][] matrix, int output[][], int s, int t, int parent[]) {\n// Anzahl der Knoten im Graph\nint nodes = matrix[0].length;\n// Array das alle Knoten als nicht besucht markiert\nboolean visited[] = new boolean[nodes];\nfor (int i = 0; i &lt; nodes; ++i)\nvisited[i] = false;\n// Warteschlange, die besuchte Knoten als true markiert\nLinkedList&lt;Integer&gt; queue = new LinkedList&lt;Integer&gt;();\nqueue.add(s);\nvisited[s] = true;\nparent[s] = -1;\n// Standard BFS-Loop, entfernt Knoten aus der Warteschlange die ungleich 0 sind\nwhile (queue.size() != 0) {\nint u = queue.poll();\nfor (int v = 0; v &lt; nodes; v++) {\nif (visited[v] == false &amp;&amp; output[u][v] &gt; 0) {\n// Wenn wir einen m\u00f6glichen Pfad von s nach t finden geben wir true zur\u00fcck\nif (v == t) {\nparent[v] = u;\nreturn true;\n}\n// Wenn wir keinen m\u00f6glichen Pfad finden f\u00fcgen wir den Knoten zur Warteschlange\n// und markieren ihn als besichtigt\nqueue.add(v);\nparent[v] = u;\nvisited[v] = true;\n}\n}\n}\nreturn false;\n}\n</code></pre>"},{"location":"Problem7/","title":"Problem 7 - \"Es gibt viel zu tun! Wer macht's\"","text":"<p>W\u00e4hrend die B\u00fcrger der Stadt Schilda ganz begeistert von Ihnen sind, bekommen Sie immer mehr Auftr\u00e4ge, die Sie gar nicht mehr alleine bew\u00e4ltigen k\u00f6nnen. Sie stellen also neues Personal f\u00fcr die Projektleitung ein. Jeder Mitarbeiter hat unterschiedliche Kompetenzen und Sie wollen die Mitarbeiter so auf die Projekte verteilen, dass jedes Projekt von genau einem Mitarbeiter oder einer Mitarbeiterin mit den notwendigen Kompetenzen geleitet wird. </p> <p>Wie ordnen Sie die Mitarbeiter den Projekten zu? (Genau ein Mitarbeiter pro Projekt) (Auch diesen Algorithmus integrieren Sie in Ihr Tool \u2013 schlie\u00dflich m\u00f6chte auch die Graphschaft ihre Kr\u00e4fte gut einsetzen!)</p>"},{"location":"Problem7/#modellierung-des-problems","title":"Modellierung des Problems","text":"<p>Das Problem l\u00e4sst sich als Graphenmodell mit gerichteten Kanten darstellen. Die Mitarbeiter und Kompetenzen werden als Knoten dargestellt. Die F\u00e4higkeit eines Mitarbeiters eine bestimmte Kompetenz zu besitzen wird als Kante dargestellt. Die Kanten werden mit der Kapazit\u00e4t 1 versehen. </p> <p>Um den Graph zu modellieren werden die Java-Bibliotheken <code>JGraphT</code> und <code>JGraphX</code> verwendet. Mit <code>JGraphT</code> wird der Graph als Datenstruktur modelliert. Mit <code>JGraphX</code> wird der Graph als Grafik dargestellt und auf dem Bildschirm dargestellt.</p>"},{"location":"Problem7/#die-eingabe","title":"Die Eingabe","text":"<p>Die Buchstaben f\u00fcr die Mitarbeiter werden mit A - G bezeichnet und die Kompetenzen mit T - Z. Hierbei ist es wichtig anzumerken, dass die Anzahl der Mitarbeiter gleich der Anzahl der Kompetenzen sein muss und Jede Kompetenz von mindestens einem Mitarbeiter besetzt sein muss.</p> <pre><code>Person:             Kompetenz:\nA: Frau Maier       T: Stra\u00dfenbau\nB: Frau M\u00fcller      U: Verkehrsplanung\nC: Frau Augst       V: Arch\u00e4ologie\nD: Frau Schmidt     W: Gesamtkoordination\nE: Herr Kunze       X: Festplanung\nF: Herr Hof         Y: Wasserversorgung\nG: Frau Lustig      Z: Wettkampfausrichtung\n</code></pre> <p>Die Eingabe besteht aus einem Graphen, der aus Kanten und Knoten besteht. Diese werden aus einer <code>.txt</code> Datei gelesen und in eine Instanz der Klasse <code>AdjazenzMatrix.java</code> geladen. Diese Instanz dient als Basis f\u00fcr die Berechnung des minimalen Spannbaums.</p> <pre><code>// code/data/problem7.txt\nA B C D E F G T U V W X Y Z\nA 0 0 0 0 0 0 0 1 1 1 0 0 0 0\nB 0 0 0 0 0 0 0 0 0 0 1 1 0 0\nC 0 0 0 0 0 0 0 1 0 0 0 0 1 0\nD 0 0 0 0 0 0 0 1 1 0 0 0 0 1\nE 0 0 0 0 0 0 0 0 0 1 0 1 0 0\nF 0 0 0 0 0 0 0 1 0 0 1 0 0 0\nG 0 0 0 0 0 0 0 0 0 0 0 1 0 1\nT 0 0 0 0 0 0 0 0 0 0 0 0 0 0\nU 0 0 0 0 0 0 0 0 0 0 0 0 0 0\nV 0 0 0 0 0 0 0 0 0 0 0 0 0 0\nW 0 0 0 0 0 0 0 0 0 0 0 0 0 0\nX 0 0 0 0 0 0 0 0 0 0 0 0 0 0\nY 0 0 0 0 0 0 0 0 0 0 0 0 0 0\nZ 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n</code></pre>"},{"location":"Problem7/#die-ausgabe","title":"Die Ausgabe","text":"<p>Die Ausgabe wird als Graph in einem Fenster dargestellt und in die Datei <code>7 Aufgabenplaner.txt</code> geschrieben. Das Fenster besteht aus drei Teilen. Im oberen linken Teil wird der Eingabe-Graph mit zus\u00e4tzlichen Start- und Endknoten dargestellt. Im oberen rechten Teil wird der Ausgabe-Graph mit Start- und Endknoten dargestellt. Im unteren Teil wird die resultierende Aufgabenverteilung ausgegeben.</p> <p>Vor der Ausgabe werden die inversen/negativen Kanten, Startknoten, Endknoten und deren Kanten entfernt. Diese werden nicht ben\u00f6tigt, da sie keine Rolle spielen. </p> <p>Ein korrekte Ausgabe erf\u00fcllt folgende Eigenschaften:</p> <ul> <li> <p>Es m\u00fcssen alle Kompetenzen und Mitarbeiter in der Ausgabe vorkommen.</p> </li> <li> <p>Jeder Mitarbeiter muss genau eine Kompetenz besitzen.</p> </li> <li> <p>Es darf keine Kante geben, die von einem Mitarbeiter zu einem anderen Mitarbeiter f\u00fchrt.</p> </li> <li> <p>Es darf keine Kante geben, die von einer Kompetenz zu einer anderen Kompetenz f\u00fchrt.</p> </li> <li> <p>Es darf keine Kante geben, die von einer Kompetenz zu einem Mitarbeiter f\u00fchrt.</p> </li> <li> <p>Alle Kanten m\u00fcssen gerichtet und ungewichtet sein, also m\u00fcssen den Fluss 1 besitzen</p> </li> </ul> <p></p> <pre><code>// code/output/7 Aufgabenplaner.txt\nA B C D E F G T U V W X Y Z A 0 0 0 0 0 0 0 0 1 0 0 0 0 0 B 0 0 0 0 0 0 0 0 0 0 1 0 0 0 C 0 0 0 0 0 0 0 0 0 0 0 0 1 0 D 0 0 0 0 0 0 0 0 0 0 0 0 0 1 E 0 0 0 0 0 0 0 0 0 1 0 0 0 0 F 0 0 0 0 0 0 0 1 0 0 0 0 0 0 G 0 0 0 0 0 0 0 0 0 0 0 1 0 0 T 0 0 0 0 0 0 0 0 0 0 0 0 0 0 U 0 0 0 0 0 0 0 0 0 0 0 0 0 0 V 0 0 0 0 0 0 0 0 0 0 0 0 0 0 W 0 0 0 0 0 0 0 0 0 0 0 0 0 0 X 0 0 0 0 0 0 0 0 0 0 0 0 0 0 Y 0 0 0 0 0 0 0 0 0 0 0 0 0 0 Z 0 0 0 0 0 0 0 0 0 0 0 0 0 0 </code></pre>"},{"location":"Problem7/#resultierende-aufgabenverteilung","title":"Resultierende Aufgabenverteilung","text":"<pre><code>A: Frau Maier     -&gt;   U: Verkehrsplanung\nB: Frau M\u00fcller    -&gt;   W: Gesamtkoordination\nC: Frau Augst     -&gt;   Y: Wasserversorgung\nD: Frau Schmidt   -&gt;   Z: Wettkampfausrichtung\nE: Herr Kunze     -&gt;   V: Arch\u00e4ologie\nF: Herr Hof       -&gt;   T: Stra\u00dfenbau\nG: Frau Lustig    -&gt;   X: Festplanung\n</code></pre>"},{"location":"Problem7/#geeignete-algorithmen","title":"Geeignete Algorithmen","text":"<p>Es gibt verschiedene Algorithmen, die verwendet werden k\u00f6nnen, um den maximalen Fluss in einem gerichteten Graph zu berechnen. Einige dieser Algorithmen sind:</p> <p>Ford-Fulkerson-Algorithmus: Dieser Algorithmus ist ein iterativer Algorithmus, der in jedem Schritt den Fluss durch einen Pfad erh\u00f6ht, der vom Quellknoten zum Zielknoten f\u00fchrt und dessen Kapazit\u00e4t noch nicht vollst\u00e4ndig ausgesch\u00f6pft ist. Der Algorithmus endet, wenn kein solcher Pfad mehr existiert.</p> <p>Dinic-Algorithmus: Dieser Algorithmus ist ebenfalls ein iterativer Algorithmus, der den Fluss durch den Graph in jedem Schritt erh\u00f6ht, indem er einen Pfad vom Quellknoten zum Zielknoten sucht, dessen Kapazit\u00e4t noch nicht vollst\u00e4ndig ausgesch\u00f6pft ist. Im Gegensatz zum Ford-Fulkerson-Algorithmus verwendet der Dinic-Algorithmus jedoch eine Heuristik, um schneller zum Ergebnis zu gelangen.</p> <p>Edmonds-Karp-Algorithmus: Dieser Algorithmus ist eine Variation des Ford-Fulkerson-Algorithmus und verwendet auch eine Heuristik, um schneller zum Ergebnis zu gelangen. Im Gegensatz zum Dinic-Algorithmus verwendet der Edmonds-Karp-Algorithmus jedoch eine Breitensuche statt einer Tiefensuche, um Pfade im Graph zu finden.</p> <p>Preflow-Push-Algorithmus: Dieser Algorithmus ist ein schneller, parallelisierbarer Algorithmus, der den Fluss durch den Graph in jedem Schritt erh\u00f6ht, indem er einen Pfad vom Quellknoten zum Zielknoten sucht, dessen Kapazit\u00e4t noch nicht vollst\u00e4ndig ausgesch\u00f6pft ist. Im Gegensatz zu den anderen Algorithmen, die hier aufgef\u00fchrt sind, ist der Preflow-Push-Algorithmus jedoch nicht iterativ, sondern arbeitet in einem einzelnen Durchgang.</p>"},{"location":"Problem7/#die-laufzeit-des-algorithmus","title":"Die Laufzeit des Algorithmus","text":"<p>Zuerst wird aus der Eingabematrix eine neue Matrix erstellt, die einen zus\u00e4tzlichen Start- und Endknoten enth\u00e4lt. F\u00fcr jeden Knoten aus der ersten H\u00e4lfte der Knoten wird eine Kante vom Startknoten zu diesem Knoten hinzugef\u00fcgt.  Das gleiche wird umgekehrt f\u00fcr die zweite H\u00e4lfte der Knoten mit dem Endknoten gemacht. Die Laufzeit hierf\u00fcr betr\u00e4gt O(V^2). </p> <p>Die Laufzeit der Funktion <code>bfs()</code> ist O(V + E). In jedem Schritt wird ein Knoten aus der Warteschlange entfernt und die Nachbarknoten des Knotens werden in die Warteschlange aufgenommen. Da jeder Knoten nur einmal in die Warteschlange aufgenommen wird und jede Kante nur einmal betrachtet wird, betr\u00e4gt die Laufzeit O(V + E).</p> <p>Die Laufzeit des Ford-Fulkerson-Algorithmus ist O(V * E^2). Der Algorithmus wird in jedem Schritt iterativ ausgef\u00fchrt, bis kein Pfad mehr vom Quellknoten zum Zielknoten verf\u00fcgbar ist, der dessen Kapazit\u00e4t noch nicht vollst\u00e4ndig ausgesch\u00f6pft hat. In jedem Schritt wird eine Breitensuche ausgef\u00fchrt, um einen solchen Pfad zu finden. </p> <p>Da am Ende der <code>fordFulkerson(int[][] matrix)</code> Funktion noch eine Ausgabematrix erzeugt wird erh\u00f6ht sich die Laufzeit um O(V^2). Mit der gleichen Laufzeit werden zus\u00e4tzlich noch die inversen Kanten des Graphen entfernt.</p> <pre><code>// Filtere die inversen Kanten\nfor (int i = 0; i &lt; matrix_output.length; i++)\nfor (int j = 0; j &lt; matrix_output[i].length; j++)\nif (matrix_output[i][j] &lt; 0)\nmatrix_output[i][j] = 0;\n</code></pre> <p>Nachdem die inversen Kanten entfernt wurden, wird eine neue Ausgabematrix ohne Start- und Endknoten und ohne deren Kanten erstellt. Die Laufzeit hierf\u00fcr betr\u00e4gt O(V^2).</p> <pre><code>// Erstelle eine neue Ausgabe-Adjazenzmatrix ohne Start- und Endknoten und ohne\n// die Kanten zu diesen Knoten\nint[][] matrix_output2 = new int[matrix_output.length - 2][matrix_output[0].length - 2];\nchar[] vertex_letters_new2 = new char[vertex_letters_new.length - 2];\nfor (int i = 0; i &lt; matrix_output2.length; i++) {\nfor (int j = 0; j &lt; matrix_output2[i].length; j++)\nmatrix_output2[i][j] = matrix_output[i + 1][j + 1];\nvertex_letters_new2[i] = vertex_letters_new[i + 1];\n}\n</code></pre> <p>Daraus folgt eine Laufzeit von O(V * E^2 + V^2).</p>"},{"location":"Problem7/#die-implementierung-des-algorithmus","title":"Die Implementierung des Algorithmus","text":"<p>Zur L\u00f6sung des Problems wurde der Ford-Fulkerson-Algorithmus verwendet. Genauer gesagt wurde der Edmonds-Karp-Algorithmus verwendet, da dieser eine Breitensuche verwendet, um Pfade im Graph zu finden.  </p> <p>Zuerst wird aus der Eingabematrix eine neue Matrix erstellt, die einen zus\u00e4tzlichen Start- und Endknoten enth\u00e4lt. F\u00fcr jeden Knoten aus der ersten H\u00e4lfte der Knoten wird eine Kante vom Startknoten zu diesem Knoten hinzugef\u00fcgt.  Das gleiche wird umgekehrt f\u00fcr die zweite H\u00e4lfte der Knoten mit dem Endknoten gemacht.</p> <p>Danach wird die Matrix <code>matrix</code> in eine echte Kopie <code>output</code> kopiert. Die echte Kopie wird sp\u00e4ter als Ausgabe verwendet.</p> <p>Danach wird ein Eltern-Array <code>parent</code> erstellt, das die Elternknoten der Knoten im Graph speichert. Dieses Array wird sp\u00e4ter verwendet, um den Pfad vom Quellknoten zum Zielknoten zu finden.</p> <p>Als n\u00e4chstes wird eine Breitensuche ausgef\u00fchrt, um einen Pfad vom Quellknoten zum Zielknoten zu finden, dessen Kapazit\u00e4t noch nicht vollst\u00e4ndig ausgesch\u00f6pft ist. Die Breitensuche wird durch die Funktion <code>bfs()</code> ausgef\u00fchrt. Die Funktion <code>bfs()</code> gibt <code>true</code> zur\u00fcck, wenn ein Pfad gefunden wurde, der vom Quellknoten zum Zielknoten f\u00fchrt und dessen Kapazit\u00e4t noch nicht vollst\u00e4ndig ausgesch\u00f6pft ist. Andernfalls wird <code>false</code> zur\u00fcckgegeben.</p> <p>Als Datenstruktur der <code>bfs()</code> Funktion wird eine LinkedList verwendet. Die Laufzeit der <code>poll()</code> Funktion betr\u00e4gt O(1), da die LinkedList eine doppelt verkettete Liste ist. Die Laufzeit der <code>add()</code> Funktion betr\u00e4gt ebenfalls O(1), da die LinkedList eine doppelt verkettete Liste ist.</p> <p>Wenn ein solcher Pfad gefunden wurde, wird der minimale Fluss des Pfades berechnet. Der minimale Fluss des Pfades ist die kleinste Kapazit\u00e4t, die noch nicht vollst\u00e4ndig ausgesch\u00f6pft ist. Dieser Wert wird dann zum maximalen Fluss des Graphen addiert. </p> <p>Anschlie\u00dfend wird eine neue Ausgabematrix erstellt, die nur aus dem positiven Fluss des Graphen besteht. </p> <p>Zuletzt wird eine neue Ausgabematrix ohne Start- und Endknoten und deren Kanten erstellt. Diese Matrix wird dann als Ausgabe angezeigt und in eine Datei gespeichert.</p> <pre><code>/**\n * Laufzeit: O(V * E^2 + V^2)\n * \n * @param matrix\n * @return\n */\nprivate int[][] fordFulkerson(int[][] matrix) {\n// Anzahl der Knoten im Graph\nint nodes = matrix[0].length;\n// Die Quelle is der erste Knoten\nint source = 0;\n// Die Senke ist der letzte Knoten\nint sink = nodes - 1;\n// Flow ist zu Beginn 0\nmax_flow = 0;\nint u, v;\n// Erzeuge echte Kopie der Matrix f\u00fcr Output\nint output[][] = new int[nodes][nodes];\nfor (u = 0; u &lt; nodes; u++)\nfor (v = 0; v &lt; nodes; v++)\noutput[u][v] = matrix[u][v];\n// Erzeuge ein Eltern Array zum speichern der m\u00f6glichen BFS-Pfade\nint parent[] = new int[nodes];\n// Wenn f\u00fcr einen Pfad der BFS m\u00f6glich ist, \u00fcberpr\u00fcfe seinen maximalen Fluss\nwhile (bfs(matrix, output, source, sink, parent)) {\n// Setze den Pfad Fluss auf unendlich\nint path_flow = Integer.MAX_VALUE;\n// Finde den maximalen Fluss durch die m\u00f6glichen Pfade\nfor (u = sink; u != source; u = parent[u]) {\nv = parent[u];\npath_flow = Math.min(path_flow, output[v][u]);\n}\n// aktualisiere die Kanten aus dem Eltern Array\nfor (u = sink; u != source; u = parent[u]) {\nv = parent[u];\n// Ziehe den Fluss-Pfad den Kanten ab\noutput[v][u] -= path_flow;\n// Addiere den Fluss-Pfad auf die Inversen Kanten\noutput[u][v] += path_flow;\n}\n// Addiere die einzelnen Flusspfade auf den maximalen Fluss\nmax_flow += path_flow;\n}\n// Ziehe von der Eingabe Matrix die \u00fcbrigen Flussgewichte ab\nint[][] outputGraph = new int[nodes][nodes];\nfor (int i = 0; i &lt; matrix[0].length; i++)\nfor (int j = 0; j &lt; matrix[0].length; j++)\noutputGraph[i][j] = matrix[i][j] - output[i][j];\nreturn outputGraph;\n}\n/**\n * Laufzeit: O(V + E)\n * \n * @param matrix\n * @param output\n * @param s\n * @param t\n * @param parent\n * @return\n */\nprivate boolean bfs(int[][] matrix, int output[][], int s, int t, int parent[]) {\n// Anzahl der Knoten im Graph\nint nodes = matrix[0].length;\n// Array das alle Knoten als nicht besucht markiert\nboolean visited[] = new boolean[nodes];\nfor (int i = 0; i &lt; nodes; ++i)\nvisited[i] = false;\n// Warteschlange, die besuchte Knoten als true markiert\nLinkedList&lt;Integer&gt; queue = new LinkedList&lt;Integer&gt;();\nqueue.add(s);\nvisited[s] = true;\nparent[s] = -1;\n// Standard BFS-Loop, entfernt Knoten aus der Warteschlange die ungleich 0 sind\nwhile (queue.size() != 0) {\nint u = queue.poll();\nfor (int v = 0; v &lt; nodes; v++) {\nif (visited[v] == false &amp;&amp; output[u][v] &gt; 0) {\n// Wenn wir einen m\u00f6glichen Pfad von s nach t finden geben wir true zur\u00fcck\nif (v == t) {\nparent[v] = u;\nreturn true;\n}\n// Wenn wir keinen m\u00f6glichen Pfad finden f\u00fcgen wir den Knoten zur Warteschlange\n// und markieren ihn als besichtigt\nqueue.add(v);\nparent[v] = u;\nvisited[v] = true;\n}\n}\n}\nreturn false;\n}\n</code></pre>"}]}