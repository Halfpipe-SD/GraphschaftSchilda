{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Die Graphschaft Schilda Abstract Dieses Dokument ist die Dokumentation des Projektes \"Graphschaft Schilda\" f\u00fcr das Modul Programmiertechnik III an der TH Aschaffenburg. Die Graphschaft Schilda ist ein beschauliches \u00d6rtchen irgendwo im Nichts. Lange Zeit blieb diese Graphschaft unbehelligt vom Fortschritt, nichts tat sich in dem \u00d6rtchen. Eines Tages jedoch machte sich dort pl\u00f6tzlich das Ger\u00fccht breit, dass fernab der Graphschaft intelligente Menschen leben, die (fast) alle Probleme der Welt mit m\u00e4chtigen Algorithmen l\u00f6sen k\u00f6nnten. Die B\u00fcrger der Graphschaft machten sich also auf den Weg um diese intelligenten Menschen mit der L\u00f6sung ihrer Probleme zu beauftragen.... Aufgabenstellung Entwickeln Sie ein Planungstool, dass der Graphschaft Schilda bei der L\u00f6sung ihrer Probleme hilft. Analysieren Sie jedes der Probleme: Welche Daten sollen verarbeitet werden? Was sind die Eingaben? Was die Ausgaben? Welcher Algorithmus eignet sich? Welche Datenstruktur eignet sich? Implementieren Sie den Algorithmus (in Java), so dass bei Eingabe der entsprechenden Daten die gew\u00fcnschte Ausgabe berechnet und ausgegeben wird. Geben Sie f\u00fcr jeden implementierten Algorithmus die Laufzeit an. Da Sie sich nun schon so viel M\u00fche mit dem Tool geben, wollen Sie das Tool nat\u00fcrlich auch an andere Gemeinden verkaufen. Die Eingaben sollen daf\u00fcr generisch, d.h., f\u00fcr neue Orte, Feiern und Planungen anpassbar sein. Sie k\u00f6nnen diese Aufgabe ein 2er oder 3er Teams l\u00f6sen. Bitte geben Sie dann die Arbeitsteilung im Dokument mit an. Die 15min\u00fctige Einzelpr\u00fcfung wird auf die Projektaufgabe eingehen. Das Team Felix M\u00f6hler - GitHub Julian Thiele - GitHub Auftraggeber Prof. Barbara Sprick - Professorin f\u00fcr Praktische Informatik bei TH Aschaffenburg","title":"Startseite"},{"location":"#die-graphschaft-schilda","text":"","title":"Die Graphschaft Schilda"},{"location":"#abstract","text":"Dieses Dokument ist die Dokumentation des Projektes \"Graphschaft Schilda\" f\u00fcr das Modul Programmiertechnik III an der TH Aschaffenburg. Die Graphschaft Schilda ist ein beschauliches \u00d6rtchen irgendwo im Nichts. Lange Zeit blieb diese Graphschaft unbehelligt vom Fortschritt, nichts tat sich in dem \u00d6rtchen. Eines Tages jedoch machte sich dort pl\u00f6tzlich das Ger\u00fccht breit, dass fernab der Graphschaft intelligente Menschen leben, die (fast) alle Probleme der Welt mit m\u00e4chtigen Algorithmen l\u00f6sen k\u00f6nnten. Die B\u00fcrger der Graphschaft machten sich also auf den Weg um diese intelligenten Menschen mit der L\u00f6sung ihrer Probleme zu beauftragen....","title":"Abstract"},{"location":"#aufgabenstellung","text":"Entwickeln Sie ein Planungstool, dass der Graphschaft Schilda bei der L\u00f6sung ihrer Probleme hilft. Analysieren Sie jedes der Probleme: Welche Daten sollen verarbeitet werden? Was sind die Eingaben? Was die Ausgaben? Welcher Algorithmus eignet sich? Welche Datenstruktur eignet sich? Implementieren Sie den Algorithmus (in Java), so dass bei Eingabe der entsprechenden Daten die gew\u00fcnschte Ausgabe berechnet und ausgegeben wird. Geben Sie f\u00fcr jeden implementierten Algorithmus die Laufzeit an. Da Sie sich nun schon so viel M\u00fche mit dem Tool geben, wollen Sie das Tool nat\u00fcrlich auch an andere Gemeinden verkaufen. Die Eingaben sollen daf\u00fcr generisch, d.h., f\u00fcr neue Orte, Feiern und Planungen anpassbar sein. Sie k\u00f6nnen diese Aufgabe ein 2er oder 3er Teams l\u00f6sen. Bitte geben Sie dann die Arbeitsteilung im Dokument mit an. Die 15min\u00fctige Einzelpr\u00fcfung wird auf die Projektaufgabe eingehen.","title":"Aufgabenstellung"},{"location":"#das-team","text":"Felix M\u00f6hler - GitHub Julian Thiele - GitHub","title":"Das Team"},{"location":"#auftraggeber","text":"Prof. Barbara Sprick - Professorin f\u00fcr Praktische Informatik bei TH Aschaffenburg","title":"Auftraggeber"},{"location":"Problem1/","text":"Problem 1 - \"Stra\u00dfen m\u00fcssen her!\" Lange Zeit gab es in der Graphschaft Schilda einen Reformstau, kein Geld floss mehr in die Infrastruktur. Wie es kommen musste, wurde der Zustand der Stadt zusehends schlechter, bis die B\u00fcrger der Graphschaft den Aufbau Ihrer Stadt nun endlich selbst in die Hand nahmen. Zun\u00e4chst einmal sollen neue Stra\u00dfen gebaut werden. Zur Zeit gibt es nur einige schlammige Wege zwischen den H\u00e4usern. Diese sollen nun gepflastert werden, so dass von jedem Haus jedes andere Haus erreichbar ist. Da die B\u00fcrger der Stadt arm sind, soll der Stra\u00dfenbau insgesamt m\u00f6glichst wenig kosten. Die B\u00fcrger haben bereits einen Plan mit m\u00f6glichen Wegen erstellt. Ihre Aufgabe ist nun, das kosteng\u00fcnstigste Wegenetz zu berechnen, so dass alle H\u00e4user miteinander verbunden sind (nehmen Sie dabei pro Pflasterstein Kosten von 1 an): Modellierung des Problems Das Problem l\u00e4sst sich als Graphenmodell mit ungerichteten Kanten darstellen. Jedes Haus ist ein Knoten, die Stra\u00dfen sind die Kanten. Die Kosten der Kanten sind die Kosten f\u00fcr die Pflastersteine. Es wird eine Konfiguration an Kanten gesucht, die eine minimale anzahl an Pflastersteinen ben\u00f6tigt. Um den Graph zu modellieren werden die Java-Bibliotheken JGraphT und JGraphX verwendet. Mit JGraphT wird der Graph als Datenstruktur modelliert. Mit JGraphX wird der Graph als Grafik dargestellt und auf dem Bildschirm dargestellt. Die Eingabe Die Eingabe besteht aus einem Graphen, der aus Kanten und Knoten besteht. Diese werden aus einer .json Datei gelesen und in eine Insanz der Klasse GraphData.java geladen. Diese Insanz dient als Basis f\u00fcr die Berechnung des g\u00fcnstigsten Weges. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 { \"directed_edges\" : false , \"vertices\" : [ { \"label\" : \"House 0\" }, { \"label\" : \"House 1\" }, ... ], \"edges\" : [ { \"source\" : \"House 0\" , \"target\" : \"House 1\" , \"weight\" : 5 }, { \"source\" : \"House 0\" , \"target\" : \"House 2\" , \"weight\" : 3 }, { \"source\" : \"House 0\" , \"target\" : \"House 4\" , \"weight\" : 4 }, ... ] } Die Ausgabe Die Ausgabe wird als Graph in einem Fenster dargestellt. Das Fenster besteht aus zwei H\u00e4lften. Auf der linken Seite wird der Eingabegraph dargestellt. Auf der rechten Seite wird der berechnete Graph dargestellt. Ein korrekte Ausgabe erf\u00fcllt folgende Eigenschaften: TODO Geeignete Algorithmen TODO Beschreibung MST mit Prim kruskal Die Laufzeit des Algorithmus TODO Laufzeitberechnung O(|E| + |V| log |V|) TODO (Hier bitte auch eine Begr\u00fcndung einf\u00fcgen, ein ausf\u00fchrlicher Beweis ist nicht notwendig.) Die Implementierung des Algorithmus Zur L\u00f6sung des Problems wurde der Algorithmus von Prim implementiert. Als Datenstruktur wurde eine Priorit\u00e4tswarteschlange verwendet, die Instanzen der Klasse GraphVertex beinhaltet: 1 2 PriorityQueue < GraphVertex > queue = new PriorityQueue < GraphVertex > ( Comparator . comparingInt ( GraphVertex :: getValue )); F\u00fcr den Umgang mit Knoten und Kanten wurden drei Klassen implementiert: GraphVertex.java : Beinhaltet die Eigenschaft int value , welche den Key f\u00fcr den Algorithmus von Prim darstellt und das Objekt GraphVertex predecessor , der vom Algorithmus gesetzt wird. GraphEdge.java : Beinhaltet die Eigenschaften String source , String target und double weight . GraphData.java : Behinhaltet die Listen ArrayList<GraphEdge> und ArrayList<GraphVertex> Aufgrund der Struktur der GraphVertex und GraphEdge Klassen werden die zus\u00e4tzlichen Funktionen getNeighbors() und getEdgesBetweenTwoVertices() ben\u00f6tigt. Diese Funktionen ben\u00f6tigen zus\u00e4tzlicehe Laufzeit und werden in der Klasse GraphData implementiert. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 // Initialisiere alle Knoten mit \u221e, setze den Vorg\u00e4nger auf null for ( GraphVertex v : vertices ) { v . setValue ( Integer . MAX_VALUE ); v . setPredecessor ( null ); } // Starte mit beliebigem Startknoten // Startknoten bekommt den Wert 0 GraphVertex start = vertices . get ( 6 ); start . setValue ( 0 ); // Speichere alle Knoten in einer geeigneten Datenstruktur Q // -> Priorit\u00e4tswarteschlange PriorityQueue < GraphVertex > queue = new PriorityQueue < GraphVertex > ( Comparator . comparingInt ( GraphVertex :: getValue )); queue . addAll ( vertices ); // Solange es noch Knoten in Q gibt... while ( ! queue . isEmpty ()) { // W\u00e4hle den Knoten aus Q mit dem kleinsten Schl\u00fcssel (v) GraphVertex vertex = queue . poll (); // Speichere alle Nachbarn von v in neighbours ArrayList < GraphVertex > neighbors = GraphData . getNeighbors ( vertex , vertices , edges ); for ( GraphVertex n : neighbors ) { // Finde Kante zwischen v und n for ( GraphEdge edge : GraphData . getEdgesBetweenTwoVertices ( vertex , n , edges )) { // Wenn der Wert der Kante kleiner ist als der Wert des Knotens und der Knoten // noch in Q enthalten ist if ( edge . getWeight () >= n . getValue () || ! queue . contains ( n )) continue ; // Speichere v als vorg\u00e4nger von n und passe wert von n an n . setValue (( int ) edge . getWeight ()); n . setPredecessor ( vertex ); // Aktualisiere die Priorit\u00e4tswarteschlange queue . remove ( n ); queue . add ( n ); } } }","title":"1. Stra\u00dfen m\u00fcssen her!"},{"location":"Problem1/#problem-1-straen-mussen-her","text":"Lange Zeit gab es in der Graphschaft Schilda einen Reformstau, kein Geld floss mehr in die Infrastruktur. Wie es kommen musste, wurde der Zustand der Stadt zusehends schlechter, bis die B\u00fcrger der Graphschaft den Aufbau Ihrer Stadt nun endlich selbst in die Hand nahmen. Zun\u00e4chst einmal sollen neue Stra\u00dfen gebaut werden. Zur Zeit gibt es nur einige schlammige Wege zwischen den H\u00e4usern. Diese sollen nun gepflastert werden, so dass von jedem Haus jedes andere Haus erreichbar ist. Da die B\u00fcrger der Stadt arm sind, soll der Stra\u00dfenbau insgesamt m\u00f6glichst wenig kosten. Die B\u00fcrger haben bereits einen Plan mit m\u00f6glichen Wegen erstellt. Ihre Aufgabe ist nun, das kosteng\u00fcnstigste Wegenetz zu berechnen, so dass alle H\u00e4user miteinander verbunden sind (nehmen Sie dabei pro Pflasterstein Kosten von 1 an):","title":"Problem 1 - \"Stra\u00dfen m\u00fcssen her!\""},{"location":"Problem1/#modellierung-des-problems","text":"Das Problem l\u00e4sst sich als Graphenmodell mit ungerichteten Kanten darstellen. Jedes Haus ist ein Knoten, die Stra\u00dfen sind die Kanten. Die Kosten der Kanten sind die Kosten f\u00fcr die Pflastersteine. Es wird eine Konfiguration an Kanten gesucht, die eine minimale anzahl an Pflastersteinen ben\u00f6tigt. Um den Graph zu modellieren werden die Java-Bibliotheken JGraphT und JGraphX verwendet. Mit JGraphT wird der Graph als Datenstruktur modelliert. Mit JGraphX wird der Graph als Grafik dargestellt und auf dem Bildschirm dargestellt.","title":"Modellierung des Problems"},{"location":"Problem1/#die-eingabe","text":"Die Eingabe besteht aus einem Graphen, der aus Kanten und Knoten besteht. Diese werden aus einer .json Datei gelesen und in eine Insanz der Klasse GraphData.java geladen. Diese Insanz dient als Basis f\u00fcr die Berechnung des g\u00fcnstigsten Weges. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 { \"directed_edges\" : false , \"vertices\" : [ { \"label\" : \"House 0\" }, { \"label\" : \"House 1\" }, ... ], \"edges\" : [ { \"source\" : \"House 0\" , \"target\" : \"House 1\" , \"weight\" : 5 }, { \"source\" : \"House 0\" , \"target\" : \"House 2\" , \"weight\" : 3 }, { \"source\" : \"House 0\" , \"target\" : \"House 4\" , \"weight\" : 4 }, ... ] }","title":"Die Eingabe"},{"location":"Problem1/#die-ausgabe","text":"Die Ausgabe wird als Graph in einem Fenster dargestellt. Das Fenster besteht aus zwei H\u00e4lften. Auf der linken Seite wird der Eingabegraph dargestellt. Auf der rechten Seite wird der berechnete Graph dargestellt. Ein korrekte Ausgabe erf\u00fcllt folgende Eigenschaften: TODO","title":"Die Ausgabe"},{"location":"Problem1/#geeignete-algorithmen","text":"TODO Beschreibung MST mit Prim kruskal","title":"Geeignete Algorithmen"},{"location":"Problem1/#die-laufzeit-des-algorithmus","text":"TODO Laufzeitberechnung O(|E| + |V| log |V|) TODO (Hier bitte auch eine Begr\u00fcndung einf\u00fcgen, ein ausf\u00fchrlicher Beweis ist nicht notwendig.)","title":"Die Laufzeit des Algorithmus"},{"location":"Problem1/#die-implementierung-des-algorithmus","text":"Zur L\u00f6sung des Problems wurde der Algorithmus von Prim implementiert. Als Datenstruktur wurde eine Priorit\u00e4tswarteschlange verwendet, die Instanzen der Klasse GraphVertex beinhaltet: 1 2 PriorityQueue < GraphVertex > queue = new PriorityQueue < GraphVertex > ( Comparator . comparingInt ( GraphVertex :: getValue )); F\u00fcr den Umgang mit Knoten und Kanten wurden drei Klassen implementiert: GraphVertex.java : Beinhaltet die Eigenschaft int value , welche den Key f\u00fcr den Algorithmus von Prim darstellt und das Objekt GraphVertex predecessor , der vom Algorithmus gesetzt wird. GraphEdge.java : Beinhaltet die Eigenschaften String source , String target und double weight . GraphData.java : Behinhaltet die Listen ArrayList<GraphEdge> und ArrayList<GraphVertex> Aufgrund der Struktur der GraphVertex und GraphEdge Klassen werden die zus\u00e4tzlichen Funktionen getNeighbors() und getEdgesBetweenTwoVertices() ben\u00f6tigt. Diese Funktionen ben\u00f6tigen zus\u00e4tzlicehe Laufzeit und werden in der Klasse GraphData implementiert. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 // Initialisiere alle Knoten mit \u221e, setze den Vorg\u00e4nger auf null for ( GraphVertex v : vertices ) { v . setValue ( Integer . MAX_VALUE ); v . setPredecessor ( null ); } // Starte mit beliebigem Startknoten // Startknoten bekommt den Wert 0 GraphVertex start = vertices . get ( 6 ); start . setValue ( 0 ); // Speichere alle Knoten in einer geeigneten Datenstruktur Q // -> Priorit\u00e4tswarteschlange PriorityQueue < GraphVertex > queue = new PriorityQueue < GraphVertex > ( Comparator . comparingInt ( GraphVertex :: getValue )); queue . addAll ( vertices ); // Solange es noch Knoten in Q gibt... while ( ! queue . isEmpty ()) { // W\u00e4hle den Knoten aus Q mit dem kleinsten Schl\u00fcssel (v) GraphVertex vertex = queue . poll (); // Speichere alle Nachbarn von v in neighbours ArrayList < GraphVertex > neighbors = GraphData . getNeighbors ( vertex , vertices , edges ); for ( GraphVertex n : neighbors ) { // Finde Kante zwischen v und n for ( GraphEdge edge : GraphData . getEdgesBetweenTwoVertices ( vertex , n , edges )) { // Wenn der Wert der Kante kleiner ist als der Wert des Knotens und der Knoten // noch in Q enthalten ist if ( edge . getWeight () >= n . getValue () || ! queue . contains ( n )) continue ; // Speichere v als vorg\u00e4nger von n und passe wert von n an n . setValue (( int ) edge . getWeight ()); n . setPredecessor ( vertex ); // Aktualisiere die Priorit\u00e4tswarteschlange queue . remove ( n ); queue . add ( n ); } } }","title":"Die Implementierung des Algorithmus"},{"location":"Problem2/","text":"Problem 2 - \"Wasserversorgung\" Modellierung des Problems Die Eingabe Die Ausgabe Der Alrogithmus Die Laufzeit des Algorithmus Die Implementierung des Algorithmus","title":"2. Wasserversorgung"},{"location":"Problem2/#problem-2-wasserversorgung","text":"","title":"Problem 2 - \"Wasserversorgung\""},{"location":"Problem2/#modellierung-des-problems","text":"","title":"Modellierung des Problems"},{"location":"Problem2/#die-eingabe","text":"","title":"Die Eingabe"},{"location":"Problem2/#die-ausgabe","text":"","title":"Die Ausgabe"},{"location":"Problem2/#der-alrogithmus","text":"","title":"Der Alrogithmus"},{"location":"Problem2/#die-laufzeit-des-algorithmus","text":"","title":"Die Laufzeit des Algorithmus"},{"location":"Problem2/#die-implementierung-des-algorithmus","text":"","title":"Die Implementierung des Algorithmus"},{"location":"Problem3/","text":"Problem 3 - \"Stromversorgung\" Die Stadt floriert, alles wird moderner und so muss auch die Stromversorgung erneuert werden. Die Stadt hat bereits eruiert, wo Strommasten aufgestellt werden k\u00f6nnen. Sie haben auch festgestellt, dass es keine Barrieren in der Stadt gibt, d.h., prinzipiell k\u00f6nnten alle Strommasten miteinander verbunden werden. Aber nat\u00fcrlich wollen wir lange Leitungen m\u00f6glichst vermeiden. Deswegen schr\u00e4nken wir von vornherein ein, dass jeder Strommast nur mit maximal 5 n\u00e4chsten Nachbarn verbunden werden darf. Es stellt sich heraus, dass dies immer noch zu teuer ist. Deswegen soll dieses Netz noch einmal so reduziert werden, dass zwar alle Strommasten miteinander verbunden sind, aber Kosten insgesamt minimal sind. Wir nehmen dabei an, dass die Kosten ausschlie\u00dflich von der Leitungsl\u00e4nge abh\u00e4ngen. Modellierung des Problems Das Problem l\u00e4sst sich als Graphenmodell mit ungerichteten Kanten darstellen. Jeder Strommast ist ein Knoten, die Verbindungen sind die Kanten. Die Kosten der Kanten sind die L\u00e4nge der Stromleitungen. Es wird eine Konfiguration an Leitungen zwischen den Strommasten gesucht, die eine minimale Gesamtl\u00e4nge besitzt, und jeder Strommast mit maximal mit 5 weiteren Masten verbunden sein darf. Um den Graph zu modellieren werden die Java-Bibliotheken JGraphT und JGraphX verwendet. Mit JGraphT wird der Graph als Datenstruktur modelliert. Mit JGraphX wird der Graph als Grafik dargestellt und auf dem Bildschirm dargestellt. Die Eingabe Die Eingabe besteht aus Knoten, die aus einer .json Datei ausgelesen werden. 1 2 3 4 5 6 7 8 9 { \"directed_edges\" : false , \"vertices\" : [ { \"label\" : \"Pole 0\" }, { \"label\" : \"Pole 1\" }, { \"label\" : \"Pole 2\" }, ... ] } Mit der Funktion generate_all_edges() werden alle m\u00f6glichen Kanten mit zuf\u00e4lligen Gewichten generiert. Diese werden dann dem Input hinzugef\u00fcgt. 1 2 3 4 5 6 7 8 9 10 11 private ArrayList < GraphEdge > generate_all_edges ( ArrayList < GraphVertex > vertices ) { ArrayList < GraphEdge > output = new ArrayList < GraphEdge > (); for ( int i = 0 ; i < vertices . size (); i ++ ) { for ( int j = i + 1 ; j < vertices . size (); j ++ ) { // generate random weight and add new edge to output output . add ( new GraphEdge ( vertices . get ( i ). getLabel (), vertices . get ( j ). getLabel (), Math . round ( Math . random () * 100.0 ))); } } return output ; } Die Ausgabe Die Ausgabe wird als Graph in einem Fenster dargestellt. Das Fenster besteht aus zwei H\u00e4lften. Auf der linken Seite wird der Eingabegraph dargestellt. Auf der rechten Seite wird der berechnete Graph dargestellt. Ein korrekte Ausgabe erf\u00fcllt folgende Eigenschaften: TODO Der Alrogithmus TODO 1 2 3 4 5 6 // \u00dcberspringe die Kante e, wenn sie von einem Knoten ausgeht, der bereits mehr als 5 Kanten hat ArrayList < GraphEdge > source_edges = GraphData . getAdjacentEdges ( e . getSource (), output_edges ); ArrayList < GraphEdge > target_edges = GraphData . getAdjacentEdges ( e . getTarget (), output_edges ); if ( source_edges . size () >= max_edges || target_edges . size () >= max_edges ) continue ; Die Laufzeit des Algorithmus TODO Die Implementierung des Algorithmus 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 // Lese die Knoten und Kanten aus den Rohdaten ArrayList < GraphVertex > vertices = input . getVertices (); ArrayList < GraphEdge > edges = input . getEdges (); // Sortiere die Kanten nach Gewicht edges . sort ( Comparator . comparingDouble ( GraphEdge :: getWeight )); // erstelle einen wald 'forest' (eine menge von b\u00e4umen), wo jeder knoten ein // eigener baum ist ArrayList < ArrayList < GraphVertex >> forest = new ArrayList < ArrayList < GraphVertex >> (); for ( GraphVertex v : vertices ) { ArrayList < GraphVertex > tree = new ArrayList < GraphVertex > (); tree . add ( v ); forest . add ( tree ); } // erstelle eine liste mit den kanten des minimum spanning trees ArrayList < GraphEdge > forest_edges = new ArrayList < GraphEdge > ( edges ); // erstelle eine liste f\u00fcr die Ausgabe ArrayList < GraphEdge > output_edges = new ArrayList < GraphEdge > (); // solange der wald nicht leer ist und der baum noch nicht alle knoten enth\u00e4lt while ( forest_edges . size () > 0 ) { // entferne eine kante (u, v) aus forest GraphEdge e = forest_edges . remove ( 0 ); // finde die b\u00e4ume, die mit der Kante e verbunden sind ArrayList < GraphVertex > tree_u = null ; ArrayList < GraphVertex > tree_v = null ; for ( ArrayList < GraphVertex > t : forest ) { if ( t . contains ( GraphData . getSourceVertexFromEdge ( e , vertices ))) tree_u = t ; if ( t . contains ( GraphData . getTargetVertexFromEdge ( e , vertices ))) tree_v = t ; } // Pr\u00fcfe ob die kante e von einem vertex ausgeht, der bereits mehr als 5 kanten // hat ArrayList < GraphEdge > source_edges = GraphData . getAdjacentEdges ( e . getSource (), output_edges ); ArrayList < GraphEdge > target_edges = GraphData . getAdjacentEdges ( e . getTarget (), output_edges ); if ( source_edges . size () >= max_edges || target_edges . size () >= max_edges ) continue ; // wenn u und v in gleichen B\u00e4umen sind -> skip if ( tree_u == tree_v ) continue ; // f\u00fcge kante von u und v zur Ausgabe hinzu output_edges . add ( e ); // f\u00fcge baum von v zu baum von u hinzu (merge) for ( GraphVertex v : tree_v ) tree_u . add ( v ); forest . remove ( tree_v ); }","title":"3. Stromversorgung"},{"location":"Problem3/#problem-3-stromversorgung","text":"Die Stadt floriert, alles wird moderner und so muss auch die Stromversorgung erneuert werden. Die Stadt hat bereits eruiert, wo Strommasten aufgestellt werden k\u00f6nnen. Sie haben auch festgestellt, dass es keine Barrieren in der Stadt gibt, d.h., prinzipiell k\u00f6nnten alle Strommasten miteinander verbunden werden. Aber nat\u00fcrlich wollen wir lange Leitungen m\u00f6glichst vermeiden. Deswegen schr\u00e4nken wir von vornherein ein, dass jeder Strommast nur mit maximal 5 n\u00e4chsten Nachbarn verbunden werden darf. Es stellt sich heraus, dass dies immer noch zu teuer ist. Deswegen soll dieses Netz noch einmal so reduziert werden, dass zwar alle Strommasten miteinander verbunden sind, aber Kosten insgesamt minimal sind. Wir nehmen dabei an, dass die Kosten ausschlie\u00dflich von der Leitungsl\u00e4nge abh\u00e4ngen.","title":"Problem 3 - \"Stromversorgung\""},{"location":"Problem3/#modellierung-des-problems","text":"Das Problem l\u00e4sst sich als Graphenmodell mit ungerichteten Kanten darstellen. Jeder Strommast ist ein Knoten, die Verbindungen sind die Kanten. Die Kosten der Kanten sind die L\u00e4nge der Stromleitungen. Es wird eine Konfiguration an Leitungen zwischen den Strommasten gesucht, die eine minimale Gesamtl\u00e4nge besitzt, und jeder Strommast mit maximal mit 5 weiteren Masten verbunden sein darf. Um den Graph zu modellieren werden die Java-Bibliotheken JGraphT und JGraphX verwendet. Mit JGraphT wird der Graph als Datenstruktur modelliert. Mit JGraphX wird der Graph als Grafik dargestellt und auf dem Bildschirm dargestellt.","title":"Modellierung des Problems"},{"location":"Problem3/#die-eingabe","text":"Die Eingabe besteht aus Knoten, die aus einer .json Datei ausgelesen werden. 1 2 3 4 5 6 7 8 9 { \"directed_edges\" : false , \"vertices\" : [ { \"label\" : \"Pole 0\" }, { \"label\" : \"Pole 1\" }, { \"label\" : \"Pole 2\" }, ... ] } Mit der Funktion generate_all_edges() werden alle m\u00f6glichen Kanten mit zuf\u00e4lligen Gewichten generiert. Diese werden dann dem Input hinzugef\u00fcgt. 1 2 3 4 5 6 7 8 9 10 11 private ArrayList < GraphEdge > generate_all_edges ( ArrayList < GraphVertex > vertices ) { ArrayList < GraphEdge > output = new ArrayList < GraphEdge > (); for ( int i = 0 ; i < vertices . size (); i ++ ) { for ( int j = i + 1 ; j < vertices . size (); j ++ ) { // generate random weight and add new edge to output output . add ( new GraphEdge ( vertices . get ( i ). getLabel (), vertices . get ( j ). getLabel (), Math . round ( Math . random () * 100.0 ))); } } return output ; }","title":"Die Eingabe"},{"location":"Problem3/#die-ausgabe","text":"Die Ausgabe wird als Graph in einem Fenster dargestellt. Das Fenster besteht aus zwei H\u00e4lften. Auf der linken Seite wird der Eingabegraph dargestellt. Auf der rechten Seite wird der berechnete Graph dargestellt. Ein korrekte Ausgabe erf\u00fcllt folgende Eigenschaften: TODO","title":"Die Ausgabe"},{"location":"Problem3/#der-alrogithmus","text":"TODO 1 2 3 4 5 6 // \u00dcberspringe die Kante e, wenn sie von einem Knoten ausgeht, der bereits mehr als 5 Kanten hat ArrayList < GraphEdge > source_edges = GraphData . getAdjacentEdges ( e . getSource (), output_edges ); ArrayList < GraphEdge > target_edges = GraphData . getAdjacentEdges ( e . getTarget (), output_edges ); if ( source_edges . size () >= max_edges || target_edges . size () >= max_edges ) continue ;","title":"Der Alrogithmus"},{"location":"Problem3/#die-laufzeit-des-algorithmus","text":"TODO","title":"Die Laufzeit des Algorithmus"},{"location":"Problem3/#die-implementierung-des-algorithmus","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 // Lese die Knoten und Kanten aus den Rohdaten ArrayList < GraphVertex > vertices = input . getVertices (); ArrayList < GraphEdge > edges = input . getEdges (); // Sortiere die Kanten nach Gewicht edges . sort ( Comparator . comparingDouble ( GraphEdge :: getWeight )); // erstelle einen wald 'forest' (eine menge von b\u00e4umen), wo jeder knoten ein // eigener baum ist ArrayList < ArrayList < GraphVertex >> forest = new ArrayList < ArrayList < GraphVertex >> (); for ( GraphVertex v : vertices ) { ArrayList < GraphVertex > tree = new ArrayList < GraphVertex > (); tree . add ( v ); forest . add ( tree ); } // erstelle eine liste mit den kanten des minimum spanning trees ArrayList < GraphEdge > forest_edges = new ArrayList < GraphEdge > ( edges ); // erstelle eine liste f\u00fcr die Ausgabe ArrayList < GraphEdge > output_edges = new ArrayList < GraphEdge > (); // solange der wald nicht leer ist und der baum noch nicht alle knoten enth\u00e4lt while ( forest_edges . size () > 0 ) { // entferne eine kante (u, v) aus forest GraphEdge e = forest_edges . remove ( 0 ); // finde die b\u00e4ume, die mit der Kante e verbunden sind ArrayList < GraphVertex > tree_u = null ; ArrayList < GraphVertex > tree_v = null ; for ( ArrayList < GraphVertex > t : forest ) { if ( t . contains ( GraphData . getSourceVertexFromEdge ( e , vertices ))) tree_u = t ; if ( t . contains ( GraphData . getTargetVertexFromEdge ( e , vertices ))) tree_v = t ; } // Pr\u00fcfe ob die kante e von einem vertex ausgeht, der bereits mehr als 5 kanten // hat ArrayList < GraphEdge > source_edges = GraphData . getAdjacentEdges ( e . getSource (), output_edges ); ArrayList < GraphEdge > target_edges = GraphData . getAdjacentEdges ( e . getTarget (), output_edges ); if ( source_edges . size () >= max_edges || target_edges . size () >= max_edges ) continue ; // wenn u und v in gleichen B\u00e4umen sind -> skip if ( tree_u == tree_v ) continue ; // f\u00fcge kante von u und v zur Ausgabe hinzu output_edges . add ( e ); // f\u00fcge baum von v zu baum von u hinzu (merge) for ( GraphVertex v : tree_v ) tree_u . add ( v ); forest . remove ( tree_v ); }","title":"Die Implementierung des Algorithmus"},{"location":"Problem4/","text":"Problem 4 - \"Historische Funde\" Beim Ausheben der Wege w\u00e4hrend des Stra\u00dfenbaus wurde ein antiker Feuerwerksplan gefunden. Die Lage der pyrotechnischen Effekte und die Z\u00fcndschn\u00fcre sind noch sehr gut zu erkennen. Wie aber ist die Choreographie des Feuerwerks? In welcher Reihenfolge z\u00fcnden die Bomben? K\u00f6nnen Sie den B\u00fcrgern der Graphschaft Schilda helfen? (Unter der Annahme, dass die Z\u00fcndschnur immer mit gleichbleibender Geschwindigkeit abbrennt...) Modellierung des Problems Das Problem l\u00e4sst sich als Graphenmodell mit ungerichteten Kanten darstellen. Das Steichholz und die Feuerwerksk\u00f6rper sind die Knoten, die Z\u00fcndschn\u00fcre sind die Kanten. Die Kosten der Kanten sind die L\u00e4nge der Z\u00fcndschn\u00fcre. Es wird die korrekte Reihenfolge gesucht, in der die Feuerwerksk\u00f6rper gez\u00fcndet werden wenn das Streichholz den ersten Feuerwerksk\u00f6rper z\u00fcndet. Um den Graph zu modellieren werden die Java-Bibliotheken JGraphT und JGraphX verwendet. Mit JGraphT wird der Graph als Datenstruktur modelliert. Mit JGraphX wird der Graph als Grafik dargestellt und auf dem Bildschirm dargestellt. Die Eingabe Um das Bild der Aufgabenstellung in konkrete Daten zu \u00fcbersetzen, wurden hier Sch\u00e4tzungen der L\u00e4nge der Z\u00fcnschn\u00fcre vorgenommen und in einer Grafik dargestellt. Die Eingabe besteht aus Knoten und Kanten, die aus einer .json Datei ausgelesen werden. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 { \"directed_edges\" : false , \"vertices\" : [ { \"label\" : \"Match\" }, { \"label\" : \"Firecracker 1\" }, { \"label\" : \"Firecracker 2\" }, ... ], \"edges\" : [ { \"source\" : \"Match\" , \"target\" : \"Firecracker 1\" , \"weight\" : 1 }, { \"source\" : \"Firecracker 1\" , \"target\" : \"Firecracker 2\" , \"weight\" : 4 }, { \"source\" : \"Firecracker 1\" , \"target\" : \"Firecracker 3\" , \"weight\" : 1 }, ... ] } Die Ausgabe Die Ausgabe wird als Liste der Knoten dargestellt, in der die Knoten in der Reihenfolge aufgelistet sind, in der sie gez\u00fcndet werden. Ein korrekte Ausgabe erf\u00fcllt folgende Eigenschaften: TODO Der Alrogithmus TODO Die Laufzeit des Algorithmus Die Implementierung des Algorithmus TODO 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 // Initialisiere die Distanz im Startknoten mit 0 und in allen anderen Knoten // mit \u221e. for ( GraphVertex vertex : vertices ) { vertex . setValue ( Integer . MAX_VALUE ); vertex . setPredecessor ( null ); } vertices . get ( 0 ). setValue ( 0 ); // Speichere alle Knoten in einer Priorit\u00e4tswarteschlange queue PriorityQueue < GraphVertex > queue = new PriorityQueue < GraphVertex > ( Comparator . comparingInt ( GraphVertex :: getValue )); queue . addAll ( vertices ); // Solange es noch unbesuchte Knoten gibt, w\u00e4hle darunter denjenigen mit // minimaler Distanz aus und while ( ! queue . isEmpty ()) { // Nehme den Knoten mit dem kleinsten Wert aus der Warteschlange GraphVertex v = queue . poll (); // 1. speichere, dass dieser Knoten schon besucht wurde v . setVisited ( true ); // 2. berechne f\u00fcr alle noch unbesuchten Nachbarknoten die Summe des jeweiligen // Kantengewichtes und der Distanz im aktuellen Knoten for ( GraphVertex n : GraphData . getNeighbors ( v , vertices , edges )) { // 3. ist dieser Wert f\u00fcr einen Knoten kleiner als die // dort gespeicherte Distanz, aktualisiere sie und setze den aktuellen Knoten // als Vorg\u00e4nger. (Dieser Schritt wird auch als Update bezeichnet. ) double sum = v . getValue () + GraphData . getWeightSum ( v , n , edges ); if ( sum < n . getValue ()) { n . setValue (( int ) sum ); n . setPredecessor ( v ); // Aktualisiere die Priorit\u00e4tswarteschlange queue . remove ( n ); queue . add ( n ); } } } // Sortiere Knoten nach Distanz vertices . sort ( Comparator . comparingInt ( GraphVertex :: getValue ));","title":"4. Historische Funde"},{"location":"Problem4/#problem-4-historische-funde","text":"Beim Ausheben der Wege w\u00e4hrend des Stra\u00dfenbaus wurde ein antiker Feuerwerksplan gefunden. Die Lage der pyrotechnischen Effekte und die Z\u00fcndschn\u00fcre sind noch sehr gut zu erkennen. Wie aber ist die Choreographie des Feuerwerks? In welcher Reihenfolge z\u00fcnden die Bomben? K\u00f6nnen Sie den B\u00fcrgern der Graphschaft Schilda helfen? (Unter der Annahme, dass die Z\u00fcndschnur immer mit gleichbleibender Geschwindigkeit abbrennt...)","title":"Problem 4 - \"Historische Funde\""},{"location":"Problem4/#modellierung-des-problems","text":"Das Problem l\u00e4sst sich als Graphenmodell mit ungerichteten Kanten darstellen. Das Steichholz und die Feuerwerksk\u00f6rper sind die Knoten, die Z\u00fcndschn\u00fcre sind die Kanten. Die Kosten der Kanten sind die L\u00e4nge der Z\u00fcndschn\u00fcre. Es wird die korrekte Reihenfolge gesucht, in der die Feuerwerksk\u00f6rper gez\u00fcndet werden wenn das Streichholz den ersten Feuerwerksk\u00f6rper z\u00fcndet. Um den Graph zu modellieren werden die Java-Bibliotheken JGraphT und JGraphX verwendet. Mit JGraphT wird der Graph als Datenstruktur modelliert. Mit JGraphX wird der Graph als Grafik dargestellt und auf dem Bildschirm dargestellt.","title":"Modellierung des Problems"},{"location":"Problem4/#die-eingabe","text":"Um das Bild der Aufgabenstellung in konkrete Daten zu \u00fcbersetzen, wurden hier Sch\u00e4tzungen der L\u00e4nge der Z\u00fcnschn\u00fcre vorgenommen und in einer Grafik dargestellt. Die Eingabe besteht aus Knoten und Kanten, die aus einer .json Datei ausgelesen werden. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 { \"directed_edges\" : false , \"vertices\" : [ { \"label\" : \"Match\" }, { \"label\" : \"Firecracker 1\" }, { \"label\" : \"Firecracker 2\" }, ... ], \"edges\" : [ { \"source\" : \"Match\" , \"target\" : \"Firecracker 1\" , \"weight\" : 1 }, { \"source\" : \"Firecracker 1\" , \"target\" : \"Firecracker 2\" , \"weight\" : 4 }, { \"source\" : \"Firecracker 1\" , \"target\" : \"Firecracker 3\" , \"weight\" : 1 }, ... ] }","title":"Die Eingabe"},{"location":"Problem4/#die-ausgabe","text":"Die Ausgabe wird als Liste der Knoten dargestellt, in der die Knoten in der Reihenfolge aufgelistet sind, in der sie gez\u00fcndet werden. Ein korrekte Ausgabe erf\u00fcllt folgende Eigenschaften: TODO","title":"Die Ausgabe"},{"location":"Problem4/#der-alrogithmus","text":"TODO","title":"Der Alrogithmus"},{"location":"Problem4/#die-laufzeit-des-algorithmus","text":"","title":"Die Laufzeit des Algorithmus"},{"location":"Problem4/#die-implementierung-des-algorithmus","text":"TODO 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 // Initialisiere die Distanz im Startknoten mit 0 und in allen anderen Knoten // mit \u221e. for ( GraphVertex vertex : vertices ) { vertex . setValue ( Integer . MAX_VALUE ); vertex . setPredecessor ( null ); } vertices . get ( 0 ). setValue ( 0 ); // Speichere alle Knoten in einer Priorit\u00e4tswarteschlange queue PriorityQueue < GraphVertex > queue = new PriorityQueue < GraphVertex > ( Comparator . comparingInt ( GraphVertex :: getValue )); queue . addAll ( vertices ); // Solange es noch unbesuchte Knoten gibt, w\u00e4hle darunter denjenigen mit // minimaler Distanz aus und while ( ! queue . isEmpty ()) { // Nehme den Knoten mit dem kleinsten Wert aus der Warteschlange GraphVertex v = queue . poll (); // 1. speichere, dass dieser Knoten schon besucht wurde v . setVisited ( true ); // 2. berechne f\u00fcr alle noch unbesuchten Nachbarknoten die Summe des jeweiligen // Kantengewichtes und der Distanz im aktuellen Knoten for ( GraphVertex n : GraphData . getNeighbors ( v , vertices , edges )) { // 3. ist dieser Wert f\u00fcr einen Knoten kleiner als die // dort gespeicherte Distanz, aktualisiere sie und setze den aktuellen Knoten // als Vorg\u00e4nger. (Dieser Schritt wird auch als Update bezeichnet. ) double sum = v . getValue () + GraphData . getWeightSum ( v , n , edges ); if ( sum < n . getValue ()) { n . setValue (( int ) sum ); n . setPredecessor ( v ); // Aktualisiere die Priorit\u00e4tswarteschlange queue . remove ( n ); queue . add ( n ); } } } // Sortiere Knoten nach Distanz vertices . sort ( Comparator . comparingInt ( GraphVertex :: getValue ));","title":"Die Implementierung des Algorithmus"},{"location":"Problem5/","text":"Problem 5 - \"Die Festhochzeit - das Verteilen der Einladungen\" Modellierung des Problems Die Eingabe Die Ausgabe Der Alrogithmus Die Laufzeit des Algorithmus Die Implementierung des Algorithmus","title":"5. Die Festhochzeit"},{"location":"Problem5/#problem-5-die-festhochzeit-das-verteilen-der-einladungen","text":"","title":"Problem 5 - \"Die Festhochzeit - das Verteilen der Einladungen\""},{"location":"Problem5/#modellierung-des-problems","text":"","title":"Modellierung des Problems"},{"location":"Problem5/#die-eingabe","text":"","title":"Die Eingabe"},{"location":"Problem5/#die-ausgabe","text":"","title":"Die Ausgabe"},{"location":"Problem5/#der-alrogithmus","text":"","title":"Der Alrogithmus"},{"location":"Problem5/#die-laufzeit-des-algorithmus","text":"","title":"Die Laufzeit des Algorithmus"},{"location":"Problem5/#die-implementierung-des-algorithmus","text":"","title":"Die Implementierung des Algorithmus"},{"location":"Problem6/","text":"Problem 6 - \"Wohin nur mit den G\u00e4sten?\" Modellierung des Problems Die Eingabe Die Ausgabe Der Alrogithmus Die Laufzeit des Algorithmus Die Implementierung des Algorithmus","title":"6. Wohin nur mit den G\u00e4sten?"},{"location":"Problem6/#problem-6-wohin-nur-mit-den-gasten","text":"","title":"Problem 6 - \"Wohin nur mit den G\u00e4sten?\""},{"location":"Problem6/#modellierung-des-problems","text":"","title":"Modellierung des Problems"},{"location":"Problem6/#die-eingabe","text":"","title":"Die Eingabe"},{"location":"Problem6/#die-ausgabe","text":"","title":"Die Ausgabe"},{"location":"Problem6/#der-alrogithmus","text":"","title":"Der Alrogithmus"},{"location":"Problem6/#die-laufzeit-des-algorithmus","text":"","title":"Die Laufzeit des Algorithmus"},{"location":"Problem6/#die-implementierung-des-algorithmus","text":"","title":"Die Implementierung des Algorithmus"},{"location":"Problem7/","text":"Problem 7 - \"Es gibt viel zu tun! Wer macht's\" Modellierung des Problems Die Eingabe Die Ausgabe Der Alrogithmus Die Laufzeit des Algorithmus Die Implementierung des Algorithmus","title":"7. Es gibt viel zu tun! Wer macht's"},{"location":"Problem7/#problem-7-es-gibt-viel-zu-tun-wer-machts","text":"","title":"Problem 7 - \"Es gibt viel zu tun! Wer macht's\""},{"location":"Problem7/#modellierung-des-problems","text":"","title":"Modellierung des Problems"},{"location":"Problem7/#die-eingabe","text":"","title":"Die Eingabe"},{"location":"Problem7/#die-ausgabe","text":"","title":"Die Ausgabe"},{"location":"Problem7/#der-alrogithmus","text":"","title":"Der Alrogithmus"},{"location":"Problem7/#die-laufzeit-des-algorithmus","text":"","title":"Die Laufzeit des Algorithmus"},{"location":"Problem7/#die-implementierung-des-algorithmus","text":"","title":"Die Implementierung des Algorithmus"}]}