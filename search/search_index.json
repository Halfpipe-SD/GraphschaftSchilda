{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Die Graphschaft Schilda Abstract Dieses Dokument ist die Dokumentation des Projektes \"Graphschaft Schilda\" f\u00fcr das Modul Programmiertechnik III an der TH Aschaffenburg. Die Graphschaft Schilda ist ein beschauliches \u00d6rtchen irgendwo im Nichts. Lange Zeit blieb diese Graphschaft unbehelligt vom Fortschritt, nichts tat sich in dem \u00d6rtchen. Eines Tages jedoch machte sich dort pl\u00f6tzlich das Ger\u00fccht breit, dass fernab der Graphschaft intelligente Menschen leben, die (fast) alle Probleme der Welt mit m\u00e4chtigen Algorithmen l\u00f6sen k\u00f6nnten. Die B\u00fcrger der Graphschaft machten sich also auf den Weg um diese intelligenten Menschen mit der L\u00f6sung ihrer Probleme zu beauftragen.... Aufgabenstellung Entwickeln Sie ein Planungstool, dass der Graphschaft Schilda bei der L\u00f6sung ihrer Probleme hilft. Analysieren Sie jedes der Probleme: Welche Daten sollen verarbeitet werden? Was sind die Eingaben? Was die Ausgaben? Welcher Algorithmus eignet sich? Welche Datenstruktur eignet sich? Implementieren Sie den Algorithmus (in Java), so dass bei Eingabe der entsprechenden Daten die gew\u00fcnschte Ausgabe berechnet und ausgegeben wird. Geben Sie f\u00fcr jeden implementierten Algorithmus die Laufzeit an. Da Sie sich nun schon so viel M\u00fche mit dem Tool geben, wollen Sie das Tool nat\u00fcrlich auch an andere Gemeinden verkaufen. Die Eingaben sollen daf\u00fcr generisch, d.h., f\u00fcr neue Orte, Feiern und Planungen anpassbar sein. Sie k\u00f6nnen diese Aufgabe ein 2er oder 3er Teams l\u00f6sen. Bitte geben Sie dann die Arbeitsteilung im Dokument mit an. Die 15min\u00fctige Einzelpr\u00fcfung wird auf die Projektaufgabe eingehen. Das Team Felix M\u00f6hler - GitHub Julian Thiele - GitHub Auftraggeber Prof. Barbara Sprick - Professorin f\u00fcr Praktische Informatik bei TH Aschaffenburg","title":"Startseite"},{"location":"#die-graphschaft-schilda","text":"","title":"Die Graphschaft Schilda"},{"location":"#abstract","text":"Dieses Dokument ist die Dokumentation des Projektes \"Graphschaft Schilda\" f\u00fcr das Modul Programmiertechnik III an der TH Aschaffenburg. Die Graphschaft Schilda ist ein beschauliches \u00d6rtchen irgendwo im Nichts. Lange Zeit blieb diese Graphschaft unbehelligt vom Fortschritt, nichts tat sich in dem \u00d6rtchen. Eines Tages jedoch machte sich dort pl\u00f6tzlich das Ger\u00fccht breit, dass fernab der Graphschaft intelligente Menschen leben, die (fast) alle Probleme der Welt mit m\u00e4chtigen Algorithmen l\u00f6sen k\u00f6nnten. Die B\u00fcrger der Graphschaft machten sich also auf den Weg um diese intelligenten Menschen mit der L\u00f6sung ihrer Probleme zu beauftragen....","title":"Abstract"},{"location":"#aufgabenstellung","text":"Entwickeln Sie ein Planungstool, dass der Graphschaft Schilda bei der L\u00f6sung ihrer Probleme hilft. Analysieren Sie jedes der Probleme: Welche Daten sollen verarbeitet werden? Was sind die Eingaben? Was die Ausgaben? Welcher Algorithmus eignet sich? Welche Datenstruktur eignet sich? Implementieren Sie den Algorithmus (in Java), so dass bei Eingabe der entsprechenden Daten die gew\u00fcnschte Ausgabe berechnet und ausgegeben wird. Geben Sie f\u00fcr jeden implementierten Algorithmus die Laufzeit an. Da Sie sich nun schon so viel M\u00fche mit dem Tool geben, wollen Sie das Tool nat\u00fcrlich auch an andere Gemeinden verkaufen. Die Eingaben sollen daf\u00fcr generisch, d.h., f\u00fcr neue Orte, Feiern und Planungen anpassbar sein. Sie k\u00f6nnen diese Aufgabe ein 2er oder 3er Teams l\u00f6sen. Bitte geben Sie dann die Arbeitsteilung im Dokument mit an. Die 15min\u00fctige Einzelpr\u00fcfung wird auf die Projektaufgabe eingehen.","title":"Aufgabenstellung"},{"location":"#das-team","text":"Felix M\u00f6hler - GitHub Julian Thiele - GitHub","title":"Das Team"},{"location":"#auftraggeber","text":"Prof. Barbara Sprick - Professorin f\u00fcr Praktische Informatik bei TH Aschaffenburg","title":"Auftraggeber"},{"location":"Problem1/","text":"Problem 1 - \"Stra\u00dfen m\u00fcssen her!\" Lange Zeit gab es in der Graphschaft Schilda einen Reformstau, kein Geld floss mehr in die Infrastruktur. Wie es kommen musste, wurde der Zustand der Stadt zusehends schlechter, bis die B\u00fcrger der Graphschaft den Aufbau Ihrer Stadt nun endlich selbst in die Hand nahmen. Zun\u00e4chst einmal sollen neue Stra\u00dfen gebaut werden. Zur Zeit gibt es nur einige schlammige Wege zwischen den H\u00e4usern. Diese sollen nun gepflastert werden, so dass von jedem Haus jedes andere Haus erreichbar ist. Da die B\u00fcrger der Stadt arm sind, soll der Stra\u00dfenbau insgesamt m\u00f6glichst wenig kosten. Die B\u00fcrger haben bereits einen Plan mit m\u00f6glichen Wegen erstellt. Ihre Aufgabe ist nun, das kosteng\u00fcnstigste Wegenetz zu berechnen, so dass alle H\u00e4user miteinander verbunden sind (nehmen Sie dabei pro Pflasterstein Kosten von 1 an): Modellierung des Problems Das Problem l\u00e4sst sich als Graphenmodell mit ungerichteten Kanten darstellen. Jedes Haus ist ein Knoten, die Stra\u00dfen sind die Kanten. Die Kosten der Kanten sind die Kosten f\u00fcr die Pflastersteine. Es wird eine Konfiguration an Kanten gesucht, die eine minimale anzahl an Pflastersteinen ben\u00f6tigt. Um den Graph zu modellieren werden die Java-Bibliotheken JGraphT und JGraphX verwendet. Mit JGraphT wird der Graph als Datenstruktur modelliert. Mit JGraphX wird der Graph als Grafik dargestellt und auf dem Bildschirm dargestellt. Die Eingabe Die Eingabe besteht aus einem Graphen, der aus Kanten und Knoten besteht. Diese werden aus einer .json Datei gelesen und in eine Insanz der Klasse GraphData.java geladen. Diese Insanz dient als Basis f\u00fcr die Berechnung des g\u00fcnstigsten Weges. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 { \"directed_edges\" : false , \"vertices\" : [ { \"label\" : \"House 0\" }, { \"label\" : \"House 1\" }, ... ], \"edges\" : [ { \"source\" : \"House 0\" , \"target\" : \"House 1\" , \"weight\" : 5 }, { \"source\" : \"House 0\" , \"target\" : \"House 2\" , \"weight\" : 3 }, { \"source\" : \"House 0\" , \"target\" : \"House 4\" , \"weight\" : 4 }, ... ] } Die Ausgabe Die Ausgabe wird als Graph in einem Fenster dargestellt. Das Fenster besteht aus zwei H\u00e4lften. Auf der linken Seite wird der Eingabegraph dargestellt. Auf der rechten Seite wird der berechnete Graph dargestellt. Ein korrekte Ausgabe erf\u00fcllt folgende Eigenschaften: - TODO Geeignete Algorithmen TODO Beschreibung MST mit Prim kruskal Die Laufzeit des Algorithmus TODO Laufzeitberechnung O(|E| + |V| log |V|) TODO (Hier bitte auch eine Begr\u00fcndung einf\u00fcgen, ein ausf\u00fchrlicher Beweis ist nicht notwendig.) Die Implementierung des Algorithmus Zur L\u00f6sung des Problems wurde der Algorithmus von Prim implementiert. Als Datenstruktur wurde eine Priorit\u00e4tswarteschlange verwendet, die Instanzen der Klasse GraphVertex beinhaltet: 1 PriorityQueue < GraphVertex > q = new PriorityQueue < GraphVertex > ( new VertexComparator ()); F\u00fcr den Umgang mit Knoten und Kanten wurden drei Klassen implementiert: GraphVertex.java : Beinhaltet die Eigenschaft int value , welche den Key f\u00fcr den Algorithmus von Prim darstellt und das Objekt GraphVertex predecessor , der vom Algorithmus gesetzt wird. GraphEdge.java : Beinhaltet die Eigenschaften String source , String target und double weight . GraphData.java : Behinhaltet die Listen ArrayList<GraphEdge> und ArrayList<GraphVertex> Aufgrund der Struktur der GraphVertex und GraphEdge Klassen werden die zus\u00e4tzlichen Funktionen getNeighbors() und getEdgesBetweenTwoVertices() ben\u00f6tigt. Diese Funktionen ben\u00f6tigen zus\u00e4tzlicehe Laufzeit und werden in der Klasse GraphData implementiert. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 // Initialisiere alle Knoten mit \u221e, setze den Vorg\u00e4nger auf null for ( GraphVertex v : vertices ) { v . setValue ( Integer . MAX_VALUE ); v . setPredecessor ( null ); } // Starte mit beliebigem Startknoten, Startknoten bekommt den Wert 0 GraphVertex start = vertices . get ( 6 ); start . setValue ( 0 ); // Speichere alle Knoten in einer geeigneten Datenstruktur Q -> Priorit\u00e4tswarteschlange PriorityQueue < GraphVertex > queue = new PriorityQueue < GraphVertex > ( vertices . size (), new VertexComparator ()); queue . addAll ( vertices ); // Solange es noch Knoten in der Warteschlange gibt while ( ! queue . isEmpty ()) { // W\u00e4hle den Knoten aus Q mit dem kleinsten Schl\u00fcssel (v) GraphVertex vertex = queue . poll (); // F\u00fcr jeden Nachbarn von vertex for ( GraphVertex n : GraphData . getNeighbors ( vertex , vertices , edges )) { // F\u00fcr jede Kante zwischen vertex und n for ( GraphEdge edge : GraphData . getEdgesBetweenTwoVertices ( vertex , n , edges )) { // Wenn der Wert der Kante kleiner ist als der Wert des Knotens und der Knoten noch in Q ist if ( edge . getWeight () < n . getValue () && queue . contains ( n )) { // Speichere vertex als Vorg\u00e4nger von n und passe den Wert von n an n . setValue (( int ) edge . getWeight ()); n . setPredecessor ( vertex ); // Aktualisiere die Priorit\u00e4tswarteschlange queue . remove ( n ); queue . add ( n ); } } } }","title":"1. Stra\u00dfen m\u00fcssen her!"},{"location":"Problem1/#problem-1-straen-mussen-her","text":"Lange Zeit gab es in der Graphschaft Schilda einen Reformstau, kein Geld floss mehr in die Infrastruktur. Wie es kommen musste, wurde der Zustand der Stadt zusehends schlechter, bis die B\u00fcrger der Graphschaft den Aufbau Ihrer Stadt nun endlich selbst in die Hand nahmen. Zun\u00e4chst einmal sollen neue Stra\u00dfen gebaut werden. Zur Zeit gibt es nur einige schlammige Wege zwischen den H\u00e4usern. Diese sollen nun gepflastert werden, so dass von jedem Haus jedes andere Haus erreichbar ist. Da die B\u00fcrger der Stadt arm sind, soll der Stra\u00dfenbau insgesamt m\u00f6glichst wenig kosten. Die B\u00fcrger haben bereits einen Plan mit m\u00f6glichen Wegen erstellt. Ihre Aufgabe ist nun, das kosteng\u00fcnstigste Wegenetz zu berechnen, so dass alle H\u00e4user miteinander verbunden sind (nehmen Sie dabei pro Pflasterstein Kosten von 1 an):","title":"Problem 1 - \"Stra\u00dfen m\u00fcssen her!\""},{"location":"Problem1/#modellierung-des-problems","text":"Das Problem l\u00e4sst sich als Graphenmodell mit ungerichteten Kanten darstellen. Jedes Haus ist ein Knoten, die Stra\u00dfen sind die Kanten. Die Kosten der Kanten sind die Kosten f\u00fcr die Pflastersteine. Es wird eine Konfiguration an Kanten gesucht, die eine minimale anzahl an Pflastersteinen ben\u00f6tigt. Um den Graph zu modellieren werden die Java-Bibliotheken JGraphT und JGraphX verwendet. Mit JGraphT wird der Graph als Datenstruktur modelliert. Mit JGraphX wird der Graph als Grafik dargestellt und auf dem Bildschirm dargestellt.","title":"Modellierung des Problems"},{"location":"Problem1/#die-eingabe","text":"Die Eingabe besteht aus einem Graphen, der aus Kanten und Knoten besteht. Diese werden aus einer .json Datei gelesen und in eine Insanz der Klasse GraphData.java geladen. Diese Insanz dient als Basis f\u00fcr die Berechnung des g\u00fcnstigsten Weges. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 { \"directed_edges\" : false , \"vertices\" : [ { \"label\" : \"House 0\" }, { \"label\" : \"House 1\" }, ... ], \"edges\" : [ { \"source\" : \"House 0\" , \"target\" : \"House 1\" , \"weight\" : 5 }, { \"source\" : \"House 0\" , \"target\" : \"House 2\" , \"weight\" : 3 }, { \"source\" : \"House 0\" , \"target\" : \"House 4\" , \"weight\" : 4 }, ... ] }","title":"Die Eingabe"},{"location":"Problem1/#die-ausgabe","text":"Die Ausgabe wird als Graph in einem Fenster dargestellt. Das Fenster besteht aus zwei H\u00e4lften. Auf der linken Seite wird der Eingabegraph dargestellt. Auf der rechten Seite wird der berechnete Graph dargestellt. Ein korrekte Ausgabe erf\u00fcllt folgende Eigenschaften: - TODO","title":"Die Ausgabe"},{"location":"Problem1/#geeignete-algorithmen","text":"TODO Beschreibung MST mit Prim kruskal","title":"Geeignete Algorithmen"},{"location":"Problem1/#die-laufzeit-des-algorithmus","text":"TODO Laufzeitberechnung O(|E| + |V| log |V|) TODO (Hier bitte auch eine Begr\u00fcndung einf\u00fcgen, ein ausf\u00fchrlicher Beweis ist nicht notwendig.)","title":"Die Laufzeit des Algorithmus"},{"location":"Problem1/#die-implementierung-des-algorithmus","text":"Zur L\u00f6sung des Problems wurde der Algorithmus von Prim implementiert. Als Datenstruktur wurde eine Priorit\u00e4tswarteschlange verwendet, die Instanzen der Klasse GraphVertex beinhaltet: 1 PriorityQueue < GraphVertex > q = new PriorityQueue < GraphVertex > ( new VertexComparator ()); F\u00fcr den Umgang mit Knoten und Kanten wurden drei Klassen implementiert: GraphVertex.java : Beinhaltet die Eigenschaft int value , welche den Key f\u00fcr den Algorithmus von Prim darstellt und das Objekt GraphVertex predecessor , der vom Algorithmus gesetzt wird. GraphEdge.java : Beinhaltet die Eigenschaften String source , String target und double weight . GraphData.java : Behinhaltet die Listen ArrayList<GraphEdge> und ArrayList<GraphVertex> Aufgrund der Struktur der GraphVertex und GraphEdge Klassen werden die zus\u00e4tzlichen Funktionen getNeighbors() und getEdgesBetweenTwoVertices() ben\u00f6tigt. Diese Funktionen ben\u00f6tigen zus\u00e4tzlicehe Laufzeit und werden in der Klasse GraphData implementiert. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 // Initialisiere alle Knoten mit \u221e, setze den Vorg\u00e4nger auf null for ( GraphVertex v : vertices ) { v . setValue ( Integer . MAX_VALUE ); v . setPredecessor ( null ); } // Starte mit beliebigem Startknoten, Startknoten bekommt den Wert 0 GraphVertex start = vertices . get ( 6 ); start . setValue ( 0 ); // Speichere alle Knoten in einer geeigneten Datenstruktur Q -> Priorit\u00e4tswarteschlange PriorityQueue < GraphVertex > queue = new PriorityQueue < GraphVertex > ( vertices . size (), new VertexComparator ()); queue . addAll ( vertices ); // Solange es noch Knoten in der Warteschlange gibt while ( ! queue . isEmpty ()) { // W\u00e4hle den Knoten aus Q mit dem kleinsten Schl\u00fcssel (v) GraphVertex vertex = queue . poll (); // F\u00fcr jeden Nachbarn von vertex for ( GraphVertex n : GraphData . getNeighbors ( vertex , vertices , edges )) { // F\u00fcr jede Kante zwischen vertex und n for ( GraphEdge edge : GraphData . getEdgesBetweenTwoVertices ( vertex , n , edges )) { // Wenn der Wert der Kante kleiner ist als der Wert des Knotens und der Knoten noch in Q ist if ( edge . getWeight () < n . getValue () && queue . contains ( n )) { // Speichere vertex als Vorg\u00e4nger von n und passe den Wert von n an n . setValue (( int ) edge . getWeight ()); n . setPredecessor ( vertex ); // Aktualisiere die Priorit\u00e4tswarteschlange queue . remove ( n ); queue . add ( n ); } } } }","title":"Die Implementierung des Algorithmus"},{"location":"Problem2/","text":"Problem 2 - \"Wasserversorgung\" Modellierung des Problems Die Eingabe Die Ausgabe Der Alrogithmus Die Laufzeit des Algorithmus Die Implementierung des Algorithmus","title":"2. Wasserversorgung"},{"location":"Problem2/#problem-2-wasserversorgung","text":"","title":"Problem 2 - \"Wasserversorgung\""},{"location":"Problem2/#modellierung-des-problems","text":"","title":"Modellierung des Problems"},{"location":"Problem2/#die-eingabe","text":"","title":"Die Eingabe"},{"location":"Problem2/#die-ausgabe","text":"","title":"Die Ausgabe"},{"location":"Problem2/#der-alrogithmus","text":"","title":"Der Alrogithmus"},{"location":"Problem2/#die-laufzeit-des-algorithmus","text":"","title":"Die Laufzeit des Algorithmus"},{"location":"Problem2/#die-implementierung-des-algorithmus","text":"","title":"Die Implementierung des Algorithmus"},{"location":"Problem3/","text":"Problem 3 - \"Stromversorgung\" Modellierung des Problems Die Eingabe Die Ausgabe Die Ausgabe wird als Graph in einem Fenster dargestellt. Das Fenster besteht aus zwei H\u00e4lften. Auf der linken Seite wird der Eingabegraph dargestellt. Auf der rechten Seite wird der berechnete Graph dargestellt. Ein korrekte Ausgabe erf\u00fcllt folgende Eigenschaften: - TODO Der Alrogithmus Die Laufzeit des Algorithmus Die Implementierung des Algorithmus","title":"3. Stromversorgung"},{"location":"Problem3/#problem-3-stromversorgung","text":"","title":"Problem 3 - \"Stromversorgung\""},{"location":"Problem3/#modellierung-des-problems","text":"","title":"Modellierung des Problems"},{"location":"Problem3/#die-eingabe","text":"","title":"Die Eingabe"},{"location":"Problem3/#die-ausgabe","text":"Die Ausgabe wird als Graph in einem Fenster dargestellt. Das Fenster besteht aus zwei H\u00e4lften. Auf der linken Seite wird der Eingabegraph dargestellt. Auf der rechten Seite wird der berechnete Graph dargestellt. Ein korrekte Ausgabe erf\u00fcllt folgende Eigenschaften: - TODO","title":"Die Ausgabe"},{"location":"Problem3/#der-alrogithmus","text":"","title":"Der Alrogithmus"},{"location":"Problem3/#die-laufzeit-des-algorithmus","text":"","title":"Die Laufzeit des Algorithmus"},{"location":"Problem3/#die-implementierung-des-algorithmus","text":"","title":"Die Implementierung des Algorithmus"},{"location":"Problem4/","text":"Problem 4 - \"Historische Funde\" Modellierung des Problems Die Eingabe Die Ausgabe Der Alrogithmus Die Laufzeit des Algorithmus Die Implementierung des Algorithmus","title":"4. Historische Funde"},{"location":"Problem4/#problem-4-historische-funde","text":"","title":"Problem 4 - \"Historische Funde\""},{"location":"Problem4/#modellierung-des-problems","text":"","title":"Modellierung des Problems"},{"location":"Problem4/#die-eingabe","text":"","title":"Die Eingabe"},{"location":"Problem4/#die-ausgabe","text":"","title":"Die Ausgabe"},{"location":"Problem4/#der-alrogithmus","text":"","title":"Der Alrogithmus"},{"location":"Problem4/#die-laufzeit-des-algorithmus","text":"","title":"Die Laufzeit des Algorithmus"},{"location":"Problem4/#die-implementierung-des-algorithmus","text":"","title":"Die Implementierung des Algorithmus"},{"location":"Problem5/","text":"Problem 5 - \"Die Festhochzeit - das Verteilen der Einladungen\" Modellierung des Problems Die Eingabe Die Ausgabe Der Alrogithmus Die Laufzeit des Algorithmus Die Implementierung des Algorithmus","title":"5. Die Festhochzeit"},{"location":"Problem5/#problem-5-die-festhochzeit-das-verteilen-der-einladungen","text":"","title":"Problem 5 - \"Die Festhochzeit - das Verteilen der Einladungen\""},{"location":"Problem5/#modellierung-des-problems","text":"","title":"Modellierung des Problems"},{"location":"Problem5/#die-eingabe","text":"","title":"Die Eingabe"},{"location":"Problem5/#die-ausgabe","text":"","title":"Die Ausgabe"},{"location":"Problem5/#der-alrogithmus","text":"","title":"Der Alrogithmus"},{"location":"Problem5/#die-laufzeit-des-algorithmus","text":"","title":"Die Laufzeit des Algorithmus"},{"location":"Problem5/#die-implementierung-des-algorithmus","text":"","title":"Die Implementierung des Algorithmus"},{"location":"Problem6/","text":"Problem 6 - \"Wohin nur mit den G\u00e4sten?\" Modellierung des Problems Die Eingabe Die Ausgabe Der Alrogithmus Die Laufzeit des Algorithmus Die Implementierung des Algorithmus","title":"6. Wohin nur mit den G\u00e4sten?"},{"location":"Problem6/#problem-6-wohin-nur-mit-den-gasten","text":"","title":"Problem 6 - \"Wohin nur mit den G\u00e4sten?\""},{"location":"Problem6/#modellierung-des-problems","text":"","title":"Modellierung des Problems"},{"location":"Problem6/#die-eingabe","text":"","title":"Die Eingabe"},{"location":"Problem6/#die-ausgabe","text":"","title":"Die Ausgabe"},{"location":"Problem6/#der-alrogithmus","text":"","title":"Der Alrogithmus"},{"location":"Problem6/#die-laufzeit-des-algorithmus","text":"","title":"Die Laufzeit des Algorithmus"},{"location":"Problem6/#die-implementierung-des-algorithmus","text":"","title":"Die Implementierung des Algorithmus"},{"location":"Problem7/","text":"Problem 7 - \"Es gibt viel zu tun! Wer macht's\" Modellierung des Problems Die Eingabe Die Ausgabe Der Alrogithmus Die Laufzeit des Algorithmus Die Implementierung des Algorithmus","title":"7. Es gibt viel zu tun! Wer macht's"},{"location":"Problem7/#problem-7-es-gibt-viel-zu-tun-wer-machts","text":"","title":"Problem 7 - \"Es gibt viel zu tun! Wer macht's\""},{"location":"Problem7/#modellierung-des-problems","text":"","title":"Modellierung des Problems"},{"location":"Problem7/#die-eingabe","text":"","title":"Die Eingabe"},{"location":"Problem7/#die-ausgabe","text":"","title":"Die Ausgabe"},{"location":"Problem7/#der-alrogithmus","text":"","title":"Der Alrogithmus"},{"location":"Problem7/#die-laufzeit-des-algorithmus","text":"","title":"Die Laufzeit des Algorithmus"},{"location":"Problem7/#die-implementierung-des-algorithmus","text":"","title":"Die Implementierung des Algorithmus"}]}